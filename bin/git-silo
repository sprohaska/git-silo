#!/bin/bash

set -o errexit
set -o nounset

main() {
    argparse "$@"

    cmd_$arg_cmd
}

argparse() {
    arg_cmd=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if test $arg_cmd; then
                die "Wrong number of arguments"
            else
                validateCmd "$1"
                arg_cmd=$1
                shift
                argparse_$arg_cmd "$@"
                return
            fi
            ;;
        esac
    done
    test $arg_cmd || die "Missing command."
}

argparse_init() {
    argparse_default "$@"
}

argparse_gc() {
    opt_force=
    opt_n=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        -n)
            shift
            [ $# -ge 1 ] || die "-n must be followed by number."
            opt_n=$1
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_default() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_filter_smudge() {
    argparse_filter "$@"
}

argparse_filter_clean() {
    argparse_filter "$@"
}

argparse_filter() {
    arg_file=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if test $arg_file; then
                die "Wrong number of arguments"
            else
                arg_file=$1
                shift
            fi
            ;;
        esac
    done
    test $arg_file || die "Missing <path>."
}

argparse_add() {
    argparse_pathspec "$@"
}

argparse_checkout() {
    argparse_pathspec "$@"
}

argparse_status() {
    argparse_pathspec "$@"
}

argparse_pathspec() {
    arg_pathspec=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_fetch() {
    argparse_sync "$@"
}

argparse_push() {
    argparse_sync "$@"
}

argparse_sync() {
    opt_dry_run=
    arg_pathspec=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --dry-run)
            opt_dry_run=--dry-run
            shift
            ;;
        --)
            shift
            arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

usage() {
    cat <<EOFTXT
git-silo init
git-silo add [--] [<file>...]
git-silo checkout -- [<file>...]
git-silo status [<path>...]
git-silo push [--] [<path>...]
git-silo fetch [--] [<path>...]
git-silo gc [-f|--force] [-n <number>]
git-silo filter_smudge <path>
git-silo filter_clean <path>

  init              initialize silo in gitdir.

  add               add untracked files for silo storage.

  checkout          replace placeholders with full content.

  status            print status of files stored in silo.

  push              push silo files for current HEAD.

  fetch             fetch silo files for current HEAD.

  gc                delete silo files that are not directly referenced by
                    HEAD, tags or tips of branches and remove unused
                    entries in .gitattributes.

    -f|--force      run gc even with unstaged changes.  Note that gc might
                    modify and commit .gitattributes.

    -n <number>     keep only objects reachable from the lastest <number>
                    commits at each head.


  filter_smudge     smudge filter (see gitattributes); receives sha1 from git
                    and expands it to corresponding content from silo.  Large
                    files will not be expanded to avoid crashes with msysgit.

  filter_clean      clean filter (see gitattributes); stores file in silo and
                    returns sha1 to git.


# Known Issues

  - scp performance on Windows might be poor.  The reason is explained in

        http://support.microsoft.com/kb/823764

    As a workaround, an alternative path to a network drive can be provided by

        git config remote.origin.silourl <DRIVE:/...>

  - git might fail with mmap out-of-memory on Windows.  Git on Windows is a
    32-bit executable, which fails for large files in some situations.  There is
    now known workaround.

EOFTXT
}

validateCmd() {
    case "$1" in
        filter_smudge|filter_clean|add|status|push|fetch|init|checkout|gc)
            return 0
            ;;
        *)
            die "Invalid command '$1'."
            ;;
    esac
}

cmd_init() {
    local gitdir siloprg
    gitdir=$(git rev-parse --git-dir)
    echo "Initializing silo in '$gitdir'."
    mkdir -p "$gitdir/silo/objects"
    isSharedDir "$gitdir/objects" &&
        echo "Using shared permissions." &&
        chmod -R g+ws "$gitdir/silo"
    if ! isBareRepo; then
        configFilters
    fi
}

configFilters() {
    siloprg=$(getSiloProgram)
    git config filter.silo.clean "$siloprg filter_clean %f"
    git config filter.silo.smudge "$siloprg filter_smudge %f"
}

isBareRepo() {
    [ $(git rev-parse --is-bare-repository) = "true" ]
}

getSiloProgram() {
    local dir
    dir=$(dirname "$0")
    dir=$(cd $dir; pwd)
    base=$(basename "$0")
    printf '%s/%s' "$dir" "$base"
}

cmd_filter_clean() {
    validateHaveSilo
    if isSha1PlaceholderFile $arg_file; then
        cat
    else
        computeSha1AndStoreContentInSilo
    fi
}

computeSha1AndStoreContentInSilo() {
    local silodir sha1 subdir objfile
    silodir=$(getSiloObjectDir)
    sha1=$(computeSha1) || die "Failed to compute sha1."
    subdir=$silodir/${sha1:0:2}
    objfile=$subdir/${sha1:2}
    if [ ! -e $objfile ]; then
        mkdir -p $subdir
        cp $arg_file $objfile
        chmod a-w $objfile
    fi
    printf '%s\n' $sha1
}

cmd_filter_smudge() {
    local silodir sha1
    read sha1
    validSha1 "$sha1" || die "Invalid input; expected sha1."
    [ "$(head -c 1)" = "" ] || die "Input too large."
    silodir=$(getSiloObjectDir)
    objfile=$silodir/${sha1:0:2}/${sha1:2}
    if [ -e $objfile ]; then
        if [ $(fileSize $objfile) -lt 10000000 ]; then
            cat $objfile
        else
            printf "placeholder for file >10MB (use git-silo checkout): %s\n" \
                $arg_file >&2
            printf '%s\n' $sha1
        fi
    else
        printf "missing silo content: %s\n" \
            $arg_file >&2
        printf '%s\n' $sha1
    fi
}

# Determine file size for large files on Mac, Linux and msysgit.
# Because the output format of BSD find and GNU find differ, sed is used
# to remove all leading characters before the permission field.
# Because msysgit's ls reports the wrong size for large files, find is used
# instead.
fileSize() {
    find "$1" -ls | sed -e 's/  */ /g' -e 's/^[^-]*-/-/' | cut -d ' ' -f 5
}

validateHaveSilo() {
    local silodir
    silodir=$(getSiloObjectDir)
    [ -d "$silodir" ] || die "Missing silo '$silodir'; run 'git-silo init'."
}

getSiloObjectDir() {
    local silodir
    silodir=$(git rev-parse --git-dir)/silo/objects
    printf '%s' "$silodir"
}

computeSha1() {
    openssl sha1 | cut -d ' ' -f 2 | egrep '^[0-9a-f]{40}$'
}

validSha1() {
    egrep -q '^[0-9a-f]{40}$' <<< "$1"
}

isSha1PlaceholderFile() {
    head -n 1 "$1" | egrep -q '^[0-9a-f]{40}$'
}

cmd_add() {
    validateHaveSilo
    while read p; do
        [ "$p" = "" ] && continue
        updateGitattributes "$p"
        git add "$p"
    done <<< "$(lsUntrackedFiles)"
}

cmd_checkout() {
    validateHaveSilo
    local sha1 path err silodir objfile
    silodir=$(getSiloObjectDir)
    err=
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if ! [ -e $path ] || isSha1PlaceholderFile "$path"; then
            objfile=$silodir/${sha1:0:2}/${sha1:2}
            echo cp $sha1 "$path"
            rm -f "$path"
            mkdir -p "$(dirname "$path")"
            if ! test -e "$objfile"; then
                printf >&2 "Missing silo object for '%s'.\n" $sha1
                err=t
                continue
            fi
            ln "$objfile" "$path" >/dev/null 2>&1 ||
            cp "$objfile" "$path" || {
                printf >&2 "Failed to copy '%s' to '%s'.\n" "$objfile" "$path"
                err=t
                continue
            }
            git add -u -- "$path"  # Update index, so that 'git status' is clean.
        fi
    done <<< "$(lsSiloTracked)"
    test $err && die "There have been problems during silo checkout (see above)."
    true
}

lsUntrackedFiles() {
    git ls-files --exclude-standard --exclude=.git* -o -- "${arg_pathspec[@]}"
}

updateGitattributes() {
    local p dir base gitignore
    p="$1"
    dir="$(dirname $p)"
    base="$(basename $p)"
    gitattributes="$dir/.gitattributes"
    tmpfile="$gitattributes-tmp$$"

    [ -e "$gitattributes" ] || touch "$gitattributes"
    ( printf '/%s filter=silo -text\n' "$base" && cat "$gitattributes") |
        sort -u >"$tmpfile"
    mv "$tmpfile" "$gitattributes"
    git add "$gitattributes"
}

cmd_status() {
    validateHaveSilo
    local sha1 path
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if isSha1PlaceholderFile "$path"; then
            printf 'placeholder '
        else
            printf 'content     '
        fi
        printf '%s\n' "$path"
    done <<< "$(lsSiloTracked)"
}

lsSiloTracked() {
    local perm ty gitsha1 size path sha1
    while read perm ty gitsha1 size path; do
        [ "$path" = "" ] && continue
        if [ "$path" != "" ] && [ "$size" = 41 ] && \
            sha1=$(getSha1ForGitObject $gitsha1); then
            printf '%s %s\n' "$sha1" "$path"
        fi
    done <<< "$(lsTree)"
}

lsTree() {
    git ls-tree -rl HEAD -- "${arg_pathspec[@]}"
}

getSha1ForGitObject() {
    git show $1 | egrep '^[0-9a-f]{40}$'
}

cmd_push() {
    validateHaveSilo
    local url transport
    url=$(getRemoteUrl)
    transport=$(getTransport "$url")
    echo "pushing silo to $url"
    echo
    printUserSyncInfo
    echo
    lsSiloObjectsForHEAD |
        transport_${transport}_push "$url"
}

cmd_fetch() {
    validateHaveSilo
    local url transport
    url=$(getRemoteUrl)
    transport=$(getTransport "$url")
    echo "fetching silo from $url"
    echo
    printUserSyncInfo
    echo
    lsSiloObjectsForHEAD |
        transport_${transport}_fetch "$url"
}

transport_scp_fetch() {
    local url_host url_dir
    read url_host url_dir <<< "$(parseUrl "$1")"
    fetch_with_cp_program scp "$url_host:\"$url_dir\""
}

fetch_with_cp_program() {
    local exec_cp silodir url dir
    exec_cp=$1
    url=$2
    silodir=$(getSiloObjectDir)
    err=
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$silodir/$p" ] && continue
        if test $opt_dry_run; then
            echo Would have run: $exec_cp "$url/$p" "$silodir/$p"
        else
            dir=$(dirname $p)
            mkdir -p "$silodir/$dir"
            isSharedDir "$silodir" && chmod g+ws "$silodir/$dir" || true
            echo $exec_cp $p ...
            rm -f "$silodir/$p-tmp"
            $exec_cp "$url/$p" "$silodir/$p-tmp" || {
                printf >&2 "Failed to copy '$p'.\n"
                err=t
                continue
            }
            chmod a-w "$silodir/$p-tmp"
            mv "$silodir/$p-tmp" "$silodir/$p"
        fi
    done
    test $err && die "There have been problems during fetch (see above)."
    true
}

isSharedDir() {
    test -g "$1"
}

transport_scp_push() {
    local silodir url url_host url_dir existing
    url=$1
    silodir=$(getSiloObjectDir)
    read url_host url_dir <<< "$(parseUrl "$url")"
    existing=$(lsRemoteDir "$url_host" "$url_dir")
    while read p; do
        [ "$p" = "" ] && continue
        findLineIn "$p" "$existing" && continue
        if test $opt_dry_run; then
            echo Would have run: scp "$silodir/$p" "$url/$p"
        else
            dir=$(dirname $p)
            ssh -n "$url_host" \
                mkdir -p "'$url_dir/$dir'" '&&' \
                test -g "'$url_dir'" '&&' \
                chmod g+ws "'$url_dir/$dir'" || true
            echo scp $p ..
            scp "$silodir/$p" "$url_host:\"$url_dir/$p-tmp\""
            ssh -n "$url_host" \
                chmod a-w "'$url_dir/$p-tmp'" '&&' \
                mv "'$url_dir/$p-tmp'" "'$url_dir/$p'"
        fi
    done
}

transport_localcp_fetch() {
    fetch_with_cp_program cp "$@"
}

transport_localcp_push() {
    local silodir url url_host url_dir existing
    url=$1
    silodir=$(getSiloObjectDir)
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$url/$p" ] && continue
        if test $opt_dry_run; then
            echo Would have run: cp "$silodir/$p" "$url/$p"
        else
            dir=$(dirname $p)
            mkdir -p "$url/$dir"
            isSharedDir "$url" && chmod g+ws "$url/$dir" || true
            echo cp $p ...
            rm -f "$url/$p-tmp"
            cp "$silodir/$p" "$url/$p-tmp"
            chmod a-w "$url/$p-tmp"
            mv "$url/$p-tmp" "$url/$p"
        fi
    done
}

findLineIn() {
    grep -q "^$1\$" <<< "$2"
}

getTransport() {
    if [ "${1/://}" = "$1" ] || isWindowsAbsPath "$1"; then
        echo localcp
    else
        echo scp
    fi
}

isWindowsAbsPath() {
    grep -q '^[a-zA-Z]:/' <<< "$1"
}

parseUrl() {
    sed -e 's/:/ /' <<< "$1"
}

lsSiloObjectsForHEAD() {
    while read sha1; do
        [ "$sha1" = "" ] && continue
        objfile=${sha1:0:2}/${sha1:2}
        printf '%s\n' "$objfile"
    done <<< "$(lsSiloTracked | cut -b 1-40 | sort -u)"
}

printUserSyncInfo() {
    local sha1 path
    while read sha1 path; do
        [ "$path" = "" ] && continue
        printf '%s %s\n' $sha1 "$path"
    done <<< "$(lsSiloTracked)"
}

getRemoteUrl() {
    local url
    url=$(git config remote.origin.silourl) ||
        url=$(git config remote.origin.url) ||
        die "Failed to get URL of 'origin'."
    if grep -q '^ssh://' <<< "$url"; then
        url=$(sed -e 's@ssh://@@' -e 's@/@:/@' -e 's@//@/@' \
            -e 's@:/~@:~@' <<< "$url")
    elif grep -q '^[^:]*://' <<< "$url"; then
        die "Don't know how to use $url."
    fi
    grep -q '\.git$' <<< "$url" || url="$url/.git"
    printf '%s/silo/objects\n' "$url"
}

cmd_gc() {
    validateNoStagedChanges
    test $opt_force || validateNoUnstagedChanges
    validateHaveSilo
    gcSiloObjects
    gcAllGitattributes
}

gcSiloObjects() {
    local silodir current stored delete
    current=$(allCurrentSiloObjects)
    current=$(convertToObjectSubdirPaths <<< "$current")

    silodir=$(getSiloObjectDir)
    stored=$(lsDir "$silodir")

    delete=$(setminus "$stored" "$current")
    ( cd $silodir &&
        xargs rm -f <<< "$delete" &&
        rmdir * 2>/dev/null ||
        true )
}

lsDir() {
    cd $1 && find . -type f | sed -e 's@^\./@@'
}

lsRemoteDir() {
    ssh -n "$1" test -e "'$2'" '&&' cd "'$2'" '&&' find . -type f | sed -e 's@^\./@@'
}

allCurrentSiloObjects() {
    while read sha1; do
        [ "$sha1" = "" ] && continue
        allSiloObjectsForTree $sha1
    done <<< "$(allReachableCommits)"
}

allReachableCommits() {
    while read sha1; do
        [ "$sha1" = "" ] && continue
        if test $opt_n; then
            git rev-list -n $opt_n $sha1
        else
            git rev-list $sha1
        fi
    done <<< "$(allLocalRefs)" |
    sort -u
}

allLocalRefs() {
    git rev-parse HEAD
    git show-ref --heads --tags -s
}

allSiloObjectsForTree() {
    local tree perm ty gitsha1 size path sha1
    tree=$1
    while read perm ty gitsha1 size path; do
        [ "$path" = "" ] && continue
        if [ "$path" != "" ] && [ "$size" = 41 ] && \
            sha1=$(getSha1ForGitObject $gitsha1); then
            printf '%s\n' "$sha1"
        fi
    done <<< "$(lsFullTree $1)"
}

lsFullTree() {
    git ls-tree -rl --full-tree $1
}

convertToObjectSubdirPaths() {
    sed -e 's@^\(.\{2\}\)@\1/@'
}

setminus() {
    while read l; do
        findLineIn "$l" "$2" && continue
        printf '%s\n' "$l"
    done <<< "$1"
}

gcAllGitattributes() {
    while read p; do
        [ "$p" = "" ] && continue
        gcGitattributes $p
    done <<< "$(lsGitattributes)"
    git commit -m "git-silo gc gitattributes" &&
        git commit --amend
    true
}

gcGitattributes() {
    local attr tmpfile dir reEntry
    attr=$1
    dir=$(dirname $attr)
    tmpfile=$attr-tmp$$
    reEntry='^/.*filter=silo -text$'
    grep -v "$reEntry" $attr >$tmpfile && true
    while read path rest; do
        if [ -f "$dir/$path" ]; then
            printf '%s filter=silo -text\n' "$path" >>$tmpfile
        fi
    done <<< "$(grep "$reEntry" $attr)"
    mv $tmpfile $attr
    git add $attr
}

lsGitattributes() {
    git ls-files | egrep '^.gitattributes|/.gitattributes'
    true
}

validateNoStagedChanges() {
    no_staged_changes || die "You have staged changes."
}

validateNoUnstagedChanges() {
    no_unstaged_changes || die "You have unstaged changes."
}

no_staged_changes() {
    git diff-index --quiet --cached HEAD
}

no_unstaged_changes() {
    git diff-files --quiet
}

die() {
    echo >&2 "Error (silo): $1"
    exit 1
}

main "$@"
