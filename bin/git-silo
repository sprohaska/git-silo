#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail
set -o noglob

opt_debug=

usage() {
    cat <<\EOF
git-silo init
git-silo add [--] [<file>...]
git-silo checkout [--copy] [--link] -- [<file>...]
git-silo status [<path>...]
git-silo push \
    [--dry-run] [-v|--verbose] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<remote>] [--] [<path>... | config remote.<remote>.silopush]
git-silo fetch \
    [--dry-run] [-v|--verbose] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<remote>] [--] [<path>... | config remote.<remote>.silofetch]
git-silo gc [--gitattributes] [-f|--force] [-n <number>] [--dry-run] [--no-tags]
git-silo purge [-f|--force] [--dry-run] [--] <path>...
git-silo fsck
git-silo dedup <repo>...

  init              initialize silo.  Install clean and smudge git filters for
                    silo.  See also WILDCARD SETUP section.

  add               add untracked files for silo storage.  Creates hard link or
                    copy depending on value of 'silo.add'.  See CONFIGURATION
                    VARIABLES section.

  checkout          replace placeholders with full content.

    --copy          copy files instead of using hard link

    --link          replace checked-out copies with hard link

  status            print status of files stored in silo.

  push              push silo files for current HEAD.

    <remote>        git remote to push to (default: origin).

    <path>...       push will be limited to the given paths.  Default paths can
                    be configured with 'remote.<remote>.silopush'.  See PATHS
                    section.

  fetch             fetch silo files for current HEAD.

    <remote>        git remote to fetch from (default: origin).

    <path>...       fetch will be limited to the given paths.  Default paths
                    can be configured with 'remote.<remote>.silofetch'.  See
                    PATHS section.

  common options for push and fetch

    --dry-run       print what would be transferred.

    -v|--verbose    print more information, e.g. skipped files.

    --include=<pat> include files whose 'silo' attribute matches glob-style
                    pattern <pat>.  See TRANSFER FILTERS section.

    --exclude=<pat> exclude files whose 'silo' attribute matches glob-styl
                    pattern <pat>.  See TRANSFER FILTERS section.

    --all           include all files.  The default is to skip files whose
                    gitattributes 'silo' contains an entry 'local'.  See
                    TRANSFER FILTERS section.

  gc                remove silo files that are not directly referenced by
                    HEAD, tags or tips of branches.

    --gitattributes Also remove unused entries from '.gitattributes' and create
                    a commit if '.gitattributes' has been changed.

    -f|--force      run gc even with unstaged changes.  Note that gc might
                    modify and commit '.gitattributes'.

    -n <number>     keep only objects reachable from the latest <number>
                    commits at each local head, including tags.  Note that
                    objects that are only reachable from a remote tracking
                    branch will be removed.

    --no-tags       remove objects that are reachable only via a tag.

    --dry-run       print only what would be removed.

  purge             replace files by placeholders and remove objects from silo.
                    Since this is a very destructive operation (comparable to
                    rm -rf), 'silo.ismasterstore=false' and the '--force' flag
                    are both required to actually remove files.

    <path>...       the files to remove.

    -f|--force      required to actually remove files.

    --dry-run       print only what would be removed.

  fsck              verify silo storage.

  dedup             create hard links between repositories.  Repositories listed
                    later get linked to repositories listed earlier.
                    Deduplication might be incomplete if silo objects are owned
                    by different users and the OS restricts creation of hard
                    links.  See KNOWN ISSUES section.

# WILDCARD SETUP

Git can be told to use git silo for all files of a certain type (based on a glob
pattern).  This avoids the need to explicitly call 'git silo add' when a file is
added for the first time; a simple 'git add' will directly use git silo.  For
example, the following line in '.gitattributes' tells git to handle all mov
files using git silo:

    *.mov filter=silo -text

# PATHS

You must always either provide a path on the command line or via the config
variables 'remote.<remote>.silopush' or 'remote.<remote>.silofetch'.  Otherwise
git-silo will refuse to transfer files to protect you from accidentally starting
large transfers.  Use '-- .' to explicitly transfer everything.

# TRANSFER FILTERS

The gitattribute 'silo' can be used to limit file transfer.  Per default, files
that carry the label 'local' are not transferred.  This can be useful to handle
less important files.  They can be tracked locally, for example on a scratch
filesystem, without transferring them to a central, probably more reliable but
perhaps space-limited, storage.

'--include=<pattern>' and '--exclude=<pattern>' can be used to select files.
Each entry of the comma-separated list in gitattribute 'silo' is matched against
the glob-style <pattern>.  '--all' includes all files.  Filter order matters.
The first match decides.

For example, with the following line in '.gitattributes'

    /path silo=foo,bar,local

'path' will be

    excluded by default
    included for '--all'
    included for '--include=ba*'
    excluded for '--exclude=fo* --include=ba*'

# CONFIGURATION VARIABLES

silo.add (default 'link'): Controls behaviour of 'git silo add'.  If set to
'link', a hard link is stored and the original file's permissions set to
read-only.  If set to 'copy', a copy will be stored.  Always storing a copy
might be useful if you want to keep the file open in another application, like
Word, and use 'git-silo add' repeatedly.  When creating a hard link, the file
permissions are changed to read-only, which might confuse applications like
Word.

silo.ismasterstore (default 'true'): Unless set to 'false', some destructive
operations, such as 'purge', are not permitted.

silo.scp (default unset): Tells git-silo which program to use for scp.

silo.scpargstyle (default 'openssh'): Tells git-silo how to pass arguments to
scp.  If set to 'openssh', openssh path quoting will be use.  If set to 'putty',
arguments will be quoted as require by PuTTY's pscp.exe.  The default is
'openssh'.  If silo.scp is set to a path that contains 'pscp', silo.scpargstyle
will default to 'putty' and arguments will be passed as required by PuTTY's
pscp.exe.

GIT_SSH (environment variable): If set, git-silo will use the specified program
instead of ssh.

# KNOWN ISSUES

  - scp performance on Windows might be poor (only 1 MB/s on local network).
    The reason is that openssh, which comes with msysgit, suffers from the
    problem explained in

        http://support.microsoft.com/kb/823764

    As a workaround, install PuTTY, configure it to use pageant, and tell
    git-silo to use pscp.exe for copying files:

        git config --global silo.scp 'c:/Program Files (x86)/PuTTY/pscp.exe'

    You should now see transfer rates of several 10 MB/s on a local network.

  - scp in msysgit has been observed to fail during file transfer from Linux for
    unknown reasons.  scp of the same file from a Unix machine worked.  PuTTY's
    scp also worked.  If you experience such a problem, consider using PuTTY.

  - git might fail with mmap out-of-memory on Windows.  Git on Windows is a
    32-bit executable, which fails for large files in some situations.  There is
    now known workaround.

  - If creation of hard links between different users is restricted, some
    operations might report warnings (like 'dedup') or copy data as a fall back
    ('fetch' from local filesystem).  Since Linux 3.6, the restrictions can be
    controlled with '/proc/sys/fs/protected_hardlinks' (see proc(5)).

EOF
}

main() {
    argparse "$@"
    validateGitVersion

    cmd_$arg_cmd
}

argparse() {
    arg_cmd=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if test "$arg_cmd"; then
                die "Wrong number of arguments"
            else
                validateCmd "$1"
                arg_cmd="$1"
                shift
                argparse_$arg_cmd "$@"
                return
            fi
            ;;
        esac
    done
    test "$arg_cmd" || die "Missing command."
}

argparse_init() {
    argparse_default "$@"
}

argparse_gc() {
    opt_force=
    opt_n=
    opt_dry_run=
    opt_tags=t
    opt_gitattributes=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --gitattributes)
            opt_gitattributes=t
            shift
            ;;
        --no-tags)
            opt_tags=
            shift
            ;;
        -n)
            shift
            [ $# -ge 1 ] || die "-n must be followed by number."
            opt_n=$1
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_fsck() {
    argparse_default "$@"
}

argparse_dedup() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            break
            ;;
        esac
    done
    [ $# -ge 1 ] || die "Wrong number of arguments (expect at least two paths)."
    arg_repos=( "$@" )
}

argparse_purge() {
    opt_force=
    opt_dry_run=
    arg_pathspec=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            break
            ;;
        esac
    done
}

argparse_default() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_filter_smudge() {
    argparse_filter "$@"
}

argparse_filter_clean() {
    argparse_filter "$@"
}

argparse_filter() {
    (( $# == 1 )) || die "Missing <path>."
    arg_file="${1}"
    echo "Warning: using old-style git-silo filter, rerun 'git-silo init' to upgrade filters." >&2
}

argparse_add() {
    argparse_pathspec "$@"
}

argparse_checkout() {
    arg_pathspec=
    opt_copy=
    opt_link=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --copy)
            opt_copy=t
            shift
            ;;
        --link)
            opt_link=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_status() {
    argparse_pathspec "$@"
}

argparse_pathspec() {
    arg_pathspec=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_fetch() {
    argparse_sync "$@"
}

argparse_push() {
    argparse_sync "$@"
}

argparse_sync() {
    local arg dummy
    opt_dry_run=
    opt_verbose=
    arg_pathspec=
    arg_remote=
    arg_filter=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --dry-run)
            opt_dry_run=--dry-run
            shift
            ;;
        -v|--verbose)
            opt_verbose=t
            shift
            ;;
        --include=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "+ $arg" )
            ;;
        --exclude=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "- $arg" )
            ;;
        --all)
            arg_filter=( '+ *' )
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if ! test "$arg_remote"; then
                arg_remote="$1"
                shift
            else
                arg_pathspec=( "$@" )
                break
            fi
            ;;
        esac
    done
    (( ${#arg_filter[@]} )) || arg_filter=( '- local' )
}

validateGitVersion() {
    local version major minor
    version=$(git version)
    version=$(cut -d ' ' -f 3 <<<"$version")
    major=$(cut -d . -f 1 <<<"$version")
    minor=$(cut -d . -f 2 <<<"$version")
    [ $major -ge 1 ] && [ $minor -ge 8 ] ||
        die "git version too low (require at least version 1.8)."
}

validateCmd() {
    case "$1" in
    filter_smudge|filter_clean|add|status|push|fetch|init|checkout|gc|dedup|fsck|purge)
        return 0
        ;;
    *)
        die "Invalid command '$1'."
        ;;
    esac
}

cmd_init() {
    local gitdir siloprg
    gitdir=$(git rev-parse --git-dir)
    echo "Initializing silo in '$gitdir'."
    mkdir -p "$gitdir/silo/objects"
    if isSharedDir "$gitdir/objects"; then
        echo "Using shared permissions."
        find "$gitdir/silo" -type d -print0 | xargs -0 chmod g+ws || {
            echo >&2 "Warning: shared permissions might be incompletely initialized (see above)."
        }
    fi
    if ! isBareRepo; then
        # git-silo uses hard link operations, which modify ctime.  Tell git to
        git config core.trustctime false
        configFilters
    fi
}

configFilters() {
    local silobindir
    silobindir=$(getSiloBinDir)
    mkdir -p "${silobindir}"
    genprgFilterClean >"${silobindir}/clean"
    chmod a+x "${silobindir}/clean"
    genprgFilterSmudge >"${silobindir}/smudge"
    chmod a+x "${silobindir}/smudge"
    # The leading space is necessary to avoid msys path mangling.
    git config filter.silo.clean ' "$(git rev-parse --git-dir)/silo/bin/clean" %f'
    git config filter.silo.smudge ' "$(git rev-parse --git-dir)/silo/bin/smudge" %f'
}

isBareRepo() {
    [ $(git rev-parse --is-bare-repository) = "true" ]
}

getSiloProgram() {
    local dir prgpath
    prgpath=$(tr '\\' / <<<"$0")
    dir="$(dirname "${prgpath}")"
    dir="$(cd "${dir}"; pwd)"
    base="$(basename "${prgpath}")"
    printf '%s/%s' "${dir}" "${base}"
}

cmd_filter_clean() {
    validateHaveSilo
    if isSha1PlaceholderFile "$arg_file"; then
        tr -d '\r'
    else
        computeSha1AndStoreContentInSilo
    fi
}

genprgFilterClean() {
    genprgShbang
    genprgMainClean
    genprgFunctions \
        cmd_filter_clean \
        validateHaveSilo \
        getSiloObjectDir \
        isSha1PlaceholderFile \
        fileSize \
        computeSha1AndStoreContentInSilo \
        computeSha1 \
        mkdirWithParentsPermissions \
        isSharedDir \
        cfg_silo_add \
        die
    genprgCallMain
}

genprgFilterSmudge() {
    genprgShbang
    genprgMainSmudge
    genprgFunctions \
        cmd_filter_smudge \
        validSha1 \
        getSiloObjectDir \
        fileSize
    genprgCallMain
}

genprgShbang() {
    cat <<\EOF
#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail
set -o noglob

EOF
}

genprgMainClean() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    cmd_filter_clean
}

EOF
}

genprgMainSmudge() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    cmd_filter_smudge
}

EOF
}

genprgCallMain() {
    cat <<\EOF
main "$@"
EOF
}

genprgFunctions() {
    for f in "$@"; do
        declare -f $f
        echo
    done
}

computeSha1AndStoreContentInSilo() {
    local silodir sha1 subdir objfile
    silodir=$(getSiloObjectDir)
    sha1=$(computeSha1) || die "Failed to compute sha1."
    subdir=$silodir/${sha1:0:2}
    objfile=$subdir/${sha1:2}
    if [ ! -e "$objfile" ]; then
        mkdirWithParentsPermissions "$subdir"
        case $(cfg_silo_add) in
        link)
            ln "$arg_file" "$objfile" >/dev/null 2>&1 ||
            cp "$arg_file" "$objfile"
            chmod a-w "$objfile"
            ;;
        copy)
            cp "$arg_file" "$objfile"
            chmod a-w "$objfile"
            ;;
        esac
    fi
    printf '%s\n' $sha1
}

cfg_silo_add() {
    local option
    option=$(git config silo.add) || option=link
    case $option in
    link|copy)
        ;;  # OK
    *)
        printf "Warning: invalid option silo.add = '%s'; using 'link'.\n" "$option" >&2
        option=link
        ;;
    esac
    echo $option
}

cfg_ismasterstore() {
    git config silo.ismasterstore || echo "true"
}

cmd_filter_smudge() {
    local silodir sha1
    IFS= read -r -n 41 sha1
    validSha1 "$sha1" || die "Invalid input; expected sha1: $arg_file"
    IFS= read -r -n 1 dummy && die "Input too large."
    silodir="$(getSiloObjectDir)"
    objfile="${silodir}/${sha1:0:2}/${sha1:2}"
    if [ -e "${objfile}" ]; then
        if [ $(fileSize "${objfile}") -lt 10000000 ]; then
            cat "${objfile}"
        else
            printf "placeholder for file >10MB (use git-silo checkout): %s\n" \
                "${arg_file}" >&2
            printf '%s\n' ${sha1}
        fi
    else
        printf "missing silo content: %s\n" \
            "${arg_file}" >&2
        printf '%s\n' "${sha1}"
    fi
}

# Determine file size for large files on Mac, Linux and msysgit.
# Because the output format of BSD find and GNU find differ, sed is used
# to remove all leading characters before the permission field.
# Because msysgit's ls reports the wrong size for large files, find is used
# instead.
fileSize() {
    find "$1" -ls | sed -e 's/  */ /g' -e 's/^[^-]*-/-/' | cut -d ' ' -f 5
}

validateHaveSilo() {
    local silodir
    silodir=$(getSiloObjectDir)
    [ -d "$silodir" ] || die "Missing silo '$silodir'; run 'git-silo init'."
}

getSiloBinDir() {
    local silodir
    silodir="$(git rev-parse --git-dir)"
    silodir="$(cd "${silodir}" && pwd)"
    silodir="${silodir}/silo/bin"
    printf '%s' "${silodir}"
}

getSiloObjectDir() {
    local silodir
    silodir=$(git rev-parse --git-dir)
    silodir=$(cd "$silodir" && pwd)
    silodir="$silodir/silo/objects"
    printf '%s' "$silodir"
}

computeSha1() {
    openssl sha1 | cut -d ' ' -f 2 | egrep '^[0-9a-f]{40}$'
}

validSha1() {
    egrep -q '^[0-9a-f]{40}$' <<< "$1"
}

# Files should not end in CRLF, because .gitattributes sets -text on
# placeholders.  In case, however, the file get checked out with CRLF, it should
# be accepted as a placeholder.
isSha1PlaceholderFile() {
    local size=$(fileSize "$1")
    [ $size -eq 41 -o $size -eq 42 ] &&
    egrep -q $'^[0-9a-f]{40}\r?$' "$1"
}

cmd_add() {
    validateHaveSilo
    while read p; do
        [ "$p" = "" ] && continue
        updateGitattributes "$p"
        git add "$p"
    done <<< "$(lsUntrackedFiles)"
}

cmd_checkout() {
    validateHaveSilo
    local sha1 path silodir objfile
    silodir=$(getSiloObjectDir)
    local haveErr=
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if ! [ -e "$path" ] ||
            isSha1PlaceholderFile "$path" ||
            ( test $opt_copy && [ $(linkCount "$path") -gt 1 ] ) ||
            ( test $opt_link && [ $(linkCount "$path") -eq 1 ] )
        then
            objfile=$silodir/${sha1:0:2}/${sha1:2}
            if ! test -e "$objfile"; then
                printf >&2 "missing silo content: %s\n" "$path"
                haveErr=t
                continue
            fi
            mkdir -p "$(dirname "$path")"
            (
                ! test $opt_copy &&
                rm -f "$path" &&
                ln "$objfile" "$path" >/dev/null 2>&1 && (
                    ! test -w "$path" ||
                    chmod a-w "$path" >/dev/null 2>&1 || (
                        test $opt_link &&
                        echo "Warning: failed to set read-only permissions, falling back to copy '$path'." >&2 &&
                        false
                    )
                ) &&
                printf "Linking %s %s\n" "${sha1}" "${path}"
            ) || (
                rm -f "$path" &&
                cp "$objfile" "$path" &&
                chmod u+w "$path" &&
                printf "Copying %s %s\n" "${sha1}" "${path}"
            ) || {
                printf >&2 "Failed to copy '%s' to '%s'.\n" "$objfile" "$path"
                haveErr=t
                continue
            }
            git add -u -- "$path"  # Update index, so that 'git status' is clean.
        fi
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
    test $haveErr && die "There have been problems during silo checkout (see above)."
    true
}

linkCount() {
    ls -l "$1" | sed -e 's/  */ /' | cut -d ' ' -f 2
}

lsUntrackedFiles() {
    git ls-files --exclude-standard --exclude=.git* -o -- "${arg_pathspec[@]}"
}

updateGitattributes() {
    local p dir base gitignore
    p="$1"
    dir="$(dirname "$p")"
    base="$(basename "$p")"
    gitattributes="$dir/.gitattributes"
    tmpfile="$gitattributes-tmp$$"

    if hasGitSiloAttributes "${p}"; then
        return 0
    fi

    local endl=$(getWorkingCopyEndl)
    [ -e "$gitattributes" ] || touch "$gitattributes"
    ( printf '/%s filter=silo -text'$endl "$(escapeSpacesForGitattributes "$base")" && cat "$gitattributes") |
        sort -u >"$tmpfile"
    mv "$tmpfile" "$gitattributes"
    git add "$gitattributes"
}

hasGitSiloAttributes() {
    local p="${1}"
    [[ $(getAttrValue text "${p}") == "unset" ]] &&
        [[ $(getAttrValue filter "${p}") == silo ]]
}

getAttrValue() {
    local attr="${1}"
    local path="${2}"
    git check-attr "${attr}" "${path}" | cut -d ' ' -f 3
}

getWorkingCopyEndl() {
    local cfg_autocrlf
    if cfg_autocrlf=$(git config core.autocrlf) &&
            [ $cfg_autocrlf = 'true' ]; then
        echo '\r\n'
    else
        echo '\n'
    fi
}

# .gitattributes doesn't support spaces, so replace them by ?.
escapeSpacesForGitattributes() {
    tr ' ' '?' <<< "$1"
}

cmd_status() {
    validateHaveSilo
    local sha1 path
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if isSha1PlaceholderFile "$path"; then
            printf 'placeholder '
        else
            printf 'content     '
        fi
        printf '%s\n' "$path"
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

lsSiloTracked() {
    local perm ty gitsha1 size path sha1
    while read perm ty gitsha1 size path; do
        [ "$path" = "" ] && continue
        if [ "$path" != "" ] && [ "$size" = 41 ] && \
            sha1=$(getSha1ForGitObject $gitsha1); then
            printf '%s %s\n' "$sha1" "$path"
        fi
    done <<< "$(lsTree "$@")"
}

lsTree() {
    git ls-tree -rl HEAD -- "$@"
}

getSha1ForGitObject() {
    git show $1 | egrep '^[0-9a-f]{40}$'
}

cmd_push() {
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    else
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silopush) ) ||
            pathspec=()
        unset IFS
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "push"
    validateHaveSilo
    local url transport
    url=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Pushing silo to $url"
    lsSiloTracked "${pathspec[@]}" |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        sha1sAsObjectPaths |
        transport_${transport}_push "$url"
}

cmd_fetch() {
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    else
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silofetch) ) ||
            pathspec=()
        unset IFS
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "fetch"
    validateHaveSilo
    local url transport
    url=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Fetching silo from $url"
    lsSiloTracked "${pathspec[@]}" |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        sha1sAsObjectPaths |
        transport_${transport}_fetch "$url"
}

transport_scp_fetch() {
    config_ssh
    local silodir url dir objPathMap remotep
    local url_host url_dir
    url=$1
    read url_host url_dir <<< "$(parseUrl "$url")"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    remoteObjs=$(lsRemoteDir "$url_host" "$url_dir")
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$silodir/$p" ] && continue
        if ! findLineIn "$p" "$remoteObjs"; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"
        remotep=$(makeScpUrl "$url_host" "$url_dir/$p")
        if test $opt_dry_run; then
            echo_debug "Would have run:" "$scp" "$remotep" "$silodir/$p"
        else
            dir="$(dirname "$p")"
            mkdirWithParentsPermissions "$silodir/$dir"
            echo_debug "$scp" "..."
            rm -f "$silodir/$p-tmp"
            # Avoid absolute local paths to work around msysgit limitation.
            # scp d:/... would fail.
            (
                cd "$silodir" &&
                exec_scp "$remotep" "$p-tmp"
            ) || die "Failed to copy '$p'."

            chmod a-w "$silodir/$p-tmp"
            mv "$silodir/$p-tmp" "$silodir/$p"
        fi
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

transport_scp_push() {
    config_ssh
    local silodir url objPathMap url_host url_dir existing remotep
    url=$1
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    read url_host url_dir <<< "$(parseUrl "$url")"
    existing=$(lsRemoteDir "$url_host" "$url_dir")
    while read p; do
        [ "$p" = "" ] && continue
        findLineIn "$p" "$existing" && continue
        if ! [ -f "$silodir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            remotep=$(makeScpUrl "$url_host" "$url_dir/$p")
            echo_debug "Would have run:" "$scp" "$silodir/$p" "$remotep"
        else
            dir=$(dirname $p)

            exec_ssh "$url_host" bash -s 1>&2 <<EOFPRG ||
set -o errexit
test -e '$url_dir/$dir' && exit 0
if ! test -d '$url_dir'; then
    echo "Missing silo dir '$url_dir' (run 'git-silo init' at remote to create it)."
    exit 1
fi
mkdir '$url_dir/$dir'
if test -g '$url_dir'; then
    chmod g+ws '$url_dir/$dir'
fi
EOFPRG
            die "Failed to create remote silo object subdirectory."

            echo_debug "$scp" ...
            remotep=$(makeScpUrl "$url_host" "$url_dir/$p-tmp")
            # Avoid absolute local paths to work around msysgit limitation.
            # scp d:/... would fail.
	    (
                cd "$silodir" &&
                exec_scp "$p" "$remotep"
	    ) || die "Failed to copy '$p'."

            exec_ssh "$url_host" bash -s <<EOFPRG ||
set -o errexit
chmod a-w '$url_dir/$p-tmp'
chmod g+r '$url_dir/$p-tmp'
mv '$url_dir/$p-tmp' '$url_dir/$p'
EOFPRG
            die "Failed to move remote file in place."

        fi
    done
}

config_ssh() {
    scp=$(git config silo.scp) || scp=scp
    if ! scpargstyle=$(git config silo.scpargstyle); then
        case "$scp" in
        *pscp*)
            scpargstyle=putty
            ;;
        *)
            scpargstyle=openssh
            ;;
        esac
    fi
}

exec_scp() {
    local defaultargs=
    case $scpargstyle in
    putty)
        defaultargs=-batch
        ;;
    esac
    "$scp" $defaultargs "$@"
}

exec_ssh() {
    local defaultargs=
    local ssh=${GIT_SSH:-ssh}
    case "$ssh" in
    *plink*)
        defaultargs=-batch
        ;;
    esac
    "$ssh" $defaultargs "$@"
}

makeScpUrl() {
    local host=$1
    local dir=$2
    case $scpargstyle in
    putty)
        printf '%s:%s' "$host" "$dir"
        ;;
    openssh)
        printf '%s:"%s"' "$host" "$dir"
        ;;
    esac
}

transport_localcp_fetch() {
    local silodir url dir objPathMap src dest tmp
    url=$1
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        src="${url}/${p}"
        dest="${silodir}/${p}"
        [ -f "${dest}" ] && continue
        if ! [ -e "${src}" ]; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"

        if test $opt_dry_run; then
           continue
        fi

        dir="$(dirname "$p")"
        mkdirWithParentsPermissions "$silodir/$dir"

        # Try to link, but only if source has correct permissions.
        if ! test -w "${src}"; then
            echo_debug "ln $src ..."
            if ln "${src}" "${dest}" >/dev/null 2>&1; then
                continue
            fi
        fi

        echo_debug "cp ${src} ..."
        tmp="${dest}-tmp"
        rm -f "${tmp}"
        cp "${src}" "${tmp}" ||
            die "Failed to copy '$p'."
        chmod a-w "${tmp}"
        mv "${tmp}" "${dest}"
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

transport_localcp_push() {
    local silodir url objPathMap url_host url_dir existing
    url=$1
    if ! [ -d "$url" ]; then
        die "Missing silo dir '$url' (run 'git-silo init' at remote to create it)."
    fi
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$url/$p" ] && continue
        if ! [ -f "$silodir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            echo_debug "Would have run: cp" "$silodir/$p" "$url/$p"
        else
            dir=$(dirname $p)
            mkdirWithParentsPermissions "$url/$dir"
            echo_debug "cp ..."
            rm -f "$url/$p-tmp"
            cp "$silodir/$p" "$url/$p-tmp"
            chmod a-w "$url/$p-tmp"
            chmod g+r "$url/$p-tmp"
            mv "$url/$p-tmp" "$url/$p"
        fi
    done
}

printSyncInfo() {
    local msg=$1
    local p=$2
    local objPathMap=$3
    local sha1=$(cut -b 1-2,4-41 <<<"$p")
    grep $sha1 <<<"$objPathMap" |
        sed -e "s/^/$msg /"
}

mkdirWithParentsPermissions() {
    local d=$1
    local parentd=$(dirname "$d")
    if [ -d "$d" ]; then
        return 0
    fi
    mkdir -p "$d"
    if isSharedDir "$parentd"; then
        chmod g+ws "$d"
    fi
}

isSharedDir() {
    test -g "$1"
}

# Lines must not contain special basic regex characters.
# SHA1s are ok.  Relative silo object paths 'xx/xxx...' are also ok.
findLineIn() {
    grep -q "^$1\$" <<< "$2"
}

getTransport() {
    if [ "${1/://}" = "$1" ] || isWindowsAbsPath "$1"; then
        echo localcp
    else
        echo scp
    fi
}

isWindowsAbsPath() {
    grep -q '^[a-zA-Z]:/' <<< "$1"
}

parseUrl() {
    sed -e 's/:/ /' <<< "$1"
}

uniqSha1s() {
    cut -b 1-40 |
    sort -u
}

sha1sAsObjectPaths() {
    while read sha1; do
        [ "$sha1" = "" ] && continue
        sha1AsObjectPath "${sha1}"
    done
}

sha1AsObjectPath() {
    local sha1="$1"
    echo ${sha1:0:2}/${sha1:2}
}

filterSiloAttr() {
    local attr
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue
        attr=$(getAttrValue "silo" "${path}")
        if ! passFilter "$attr" "$@"; then
            test $opt_verbose && printf "    skipping %s\n" "${path}" >&2
            continue
        fi
        printf '%s %s\n' "${sha1}" "${path}"
    done
}

passFilter() {
    local attr=$1
    shift
    for f in "$@"; do
        read -r cmd label <<<"${f}"
        case ",${attr}," in
        *,${label},*)
            case "${cmd}" in
            +)
                return 0
                ;;
            -)
                return 1
                ;;
            *)
                die "Invalid filter command in filter rule '${cmd} ${label}'."
            esac
            ;;
        esac
    done
    return 0
}

getRemoteSiloUrl() {
    local url reurl
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    url=$(git config remote."${remote}".url) ||
        die "Failed to get URL of remote '${remote}'.  If you meant '${remote}' to be a path, separate it by a double dash: '-- ${remote} ...'."
    if grep -q '^ssh://' <<< "$url"; then
        url=$(sed -e 's@ssh://@@' -e 's@/@:/@' -e 's@//@/@' \
            -e 's@:/~@:~@' <<< "$url")
    elif grep -q '^[^:]*://' <<< "$url"; then
        die "Don't know how to use $url."
    fi
    reurl=$(resolveGitDir "$url") ||
        die "Failed to resolve git-dir for '$url'."
    printf '%s/silo/objects\n' "$reurl"
}

resolveGitDir() {
    local url=$1
    local url_host url_dir
    case $(getTransport "$url") in
    localcp)
        url=$(cd "$url" && cd "$(git rev-parse --git-dir)" && pwd)
        ;;
    scp)
        read url_host url_dir <<< "$(parseUrl "$url")"
        url_dir=$(
            exec_ssh "$url_host" bash -s <<EOFPRG
set -o errexit
test -e '$url_dir'
cd '$url_dir'
cd "\$(git rev-parse --git-dir)"
pwd
EOFPRG
        ) || die "Failed 'ssh $url_host bash ...' to determine git-dir."
        url=$url_host:$url_dir
        ;;
    esac
    printf '%s' "$url"
}

cmd_gc() {
    validateNoStagedChanges
    test $opt_force || validateNoUnstagedChanges
    validateHaveSilo
    gcSiloObjects
    if test $opt_gitattributes; then
        gcAllGitattributes
    fi
}

gcSiloObjects() {
    local silodir current stored remove
    current=$(allCurrentSiloObjects)
    current=$(convertToObjectSubdirPaths <<< "$current")

    silodir=$(getSiloObjectDir)
    stored=$(lsDir "$silodir")

    remove=$(setminus "$stored" "$current")
    if test $opt_dry_run; then
        sed -e 's/^/Would remove /' <<<"${remove}"
        return 0
    fi
    ( cd "$silodir" && xargs rm -vf ) <<<"${remove}" |
        sed -e 's/^/Removing /'
    find "${silodir}" -mindepth 1 -maxdepth 1 -type d -empty -exec rmdir '{}' ';' || true
}

cmd_purge() {
    validateHaveSilo

    local orphanSha1s silodir shouldRemoveObject sha1 path objpath
    local msg_remove msg_placeholder

    [[ $(cfg_ismasterstore) == "false" ]] ||
        die "purge requires silo.ismasterstore=false."

    test $opt_force || test $opt_dry_run ||
        die "purge requires either -f or --dry-run."

    (( ${#arg_pathspec[@]} )) ||
        die "purge requires a path."

    validateNoStagedChanges
    validateNoUnstagedChanges

    if test $opt_force; then
        msg_remove="Removing"
        msg_placeholder="Using placeholder"
    else
        msg_remove="Would remove"
        msg_placeholder="Would use placeholder"
    fi

    orphanSha1s="$(orphanSha1sWithoutPaths "${arg_pathspec[@]}")"
    silodir=$(getSiloObjectDir)

    lsSiloTracked "${arg_pathspec[@]}" |
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue

        objpath="${silodir}/$(sha1AsObjectPath "${sha1}")"
        if [ -f "${objpath}" ] && grep -q -F "${sha1}" <<<"${orphanSha1s}"; then
            shouldRemoveObject=t
            printf "%s %s %s\n" "${msg_remove}" "${sha1}" "${path}"
        elif ! isSha1PlaceholderFile "${path}"; then
            shouldRemoveObject=
            printf "%s %s %s\n" "${msg_placeholder}" "${sha1}" "${path}"
        else
            continue
        fi

        if ! test $opt_force; then
            continue
        fi

        rm -f "${path}"
        printf '%s\n' "${sha1}" >"${path}"
        git add -u "${path}"

        if ! test $shouldRemoveObject; then
            continue;
        fi

        rm -f "${objpath}"
    done

    find "${silodir}" -mindepth 1 -maxdepth 1 -type d -empty -exec rmdir '{}' ';' || true
}

# Count how often a sha1 is used (1) by all files of HEAD and (2) when files
# are restricted to paths.  Join counts on sha1 and keep only sha1s that are
# present in both sets with same count.  These sha1s become orphans when the
# paths are removed.
orphanSha1sWithoutPaths() {
    (
        lsSiloTracked | sha1Counts &&
        lsSiloTracked "$@" | sha1Counts
    ) |
    joinCounts |
    sha1sWithEqualCounts
}

# Join counts from consecutive lines with equal sha1.
joinCounts() {
    local sha1 c prevc
    local prevsha1=

    sed -e 's/^ *//' |
    sort -s -k 2 |
    while read -r c sha1; do
        [ "${sha1}" = "" ] && continue
        if [ "${sha1}" = "${prevsha1}" ]; then
            printf "%s %s %s\n" "${sha1}" "${prevc}" "${c}"
        fi
        prevsha1="${sha1}"
        prevc="${c}"
    done
}

sha1sWithEqualCounts() {
    local sha1 c1 c2
    while read -r sha1 c1 c2; do
        [ "${sha1}" = "" ] && continue
        (( $c1 != $c2 )) && continue
        printf '%s\n' "${sha1}"
    done
}

sha1Counts() {
    cut -b 1-40 |
    sort |
    uniq -c
}

lsDir() {
    cd "$1" && find . -type f | sed -e 's@^\./@@'
}

lsRemoteDir() {
    exec_ssh "$1" bash -s <<EOFPRG |
set -o errexit
if test -e '$2'; then
    cd '$2'
    find . -type f
fi
EOFPRG
    sed -e 's@^\./@@' ||
        die "Failed to list silo objects at '$1' in '$2'."
}

allCurrentSiloObjects() {
    if test $opt_n; then
        while read ref; do
            [ "$ref" = "" ] && continue
            siloObjectsWithRevListArgs -n $opt_n $ref
        done <<< "$(allLocalRefs)" |
        sort -u
    else
        siloObjectsWithRevListArgs --all
    fi
}

siloObjectsWithRevListArgs() {
    git rev-list --objects "$@" |
    cut -d ' ' -f 1 |
    git cat-file --batch-check |
    ( grep 'blob 41$' || true ) |  # Avoid pipefail without match.
    cut -d ' ' -f 1 |
    sort -u |
    while read blob; do
        [ -z "$blob" ] && continue
        if sha1=$(getSha1ForGitObject $blob); then
            printf '%s\n' "$sha1"
        fi
    done
}

allLocalRefs() {
    git rev-parse HEAD
    git show-ref --heads $(test $opt_tags && echo --tags) -s
}

allSiloObjectsForTree() {
    local tree perm ty gitsha1 size path sha1
    tree=$1
    while read perm ty gitsha1 size path; do
        [ "$path" = "" ] && continue
        if [ "$path" != "" ] && [ "$size" = 41 ] && \
            sha1=$(getSha1ForGitObject $gitsha1); then
            printf '%s\n' "$sha1"
        fi
    done <<< "$(lsFullTree $1)"
}

lsFullTree() {
    git ls-tree -rl --full-tree $1
}

convertToObjectSubdirPaths() {
    sed -e 's@^\(.\{2\}\)@\1/@'
}

# Lines must not contain special basic regex characters.
# SHA1s are ok.  Relative silo object paths 'xx/xxx...' are also ok.
setminus() {
    while read l; do
        findLineIn "$l" "$2" && continue
        printf '%s\n' "$l"
    done <<< "$1"
}

gcAllGitattributes() {
    while read p; do
        [ "$p" = "" ] && continue
        gcGitattributes $p
    done <<< "$(lsGitattributes)"
    test $opt_dry_run && return 0
    git commit -m "git-silo gc gitattributes" &&
        echo "Consider amending the commit to explain the reason."
    true
}

gcGitattributes() {
    local attr tmpfile dir reEntry
    attr=$1
    dir=$(dirname $attr)
    tmpfile=$attr-tmp$$
    reEntry='^/.*filter=silo -text$'
    grep -v "$reEntry" $attr >$tmpfile || true
    while read path rest; do
        if [ -f "$dir/$path" ]; then
            printf '%s filter=silo -text\n' "$path" >>$tmpfile
        fi
    done <<< "$(grep "$reEntry" $attr)"
    if test $opt_dry_run; then
        diff $attr $tmpfile >/dev/null || echo "Would clean up '$attr'."
        rm $tmpfile
        return 0
    fi
    mv $tmpfile $attr
    git add $attr
}

lsGitattributes() {
    git ls-files | egrep '^.gitattributes|/.gitattributes'
    true
}

cmd_fsck() {
    local silodir expected_sha1 actual_sha1
    validateHaveSilo
    silodir="$(getSiloObjectDir)"
    local haveErr=
    while read -r p; do
        expected_sha1=${p/\//}
        actual_sha1=$(computeSha1 <"$silodir/$p") ||
            die "Failed to compute sha1 for '$p'."
        if [ $expected_sha1 != $actual_sha1 ]; then
            printf 'Error: %s corrupted, has wrong sha1 %s\n' \
                "$p" "$actual_sha1"
            haveErr=t
        fi
    done <<<"$(lsSiloObjectsInDir "$silodir")"
    test $haveErr && die "There have been errors (see above)."
    echo ok
}

lsSiloObjectsInDir() {
    lsDir "$1" |
    egrep '^[0-9a-f]{2}/[0-9a-f]{38}$'
}

cmd_dedup() {
    for r in "${arg_repos[@]}"; do
        validateHaveSiloAt "$r"
    done

    local prev_key=invalid
    local prev_dir
    local src dest tmp
    lsAllDedupCandidates |
    while read -r key dir; do
        if [ $key != $prev_key ]; then
            prev_key=$key
            prev_dir=$dir
            continue
        fi
        src=$prev_dir/$key
        dest=$dir/$key
        # Skip if files already use same inode.
        if [ "$(inodeNumber "${src}")" = "$(inodeNumber "${dest}")" ]; then
            continue
        fi
        tmp=$dest-$$
        ln "$src" "$tmp" &&
        mv -f "$tmp" "$dest" || {
            printf "Warning: Failed to link '%s' from '%s' to '%s'.\n" \
                "$key" "$prev_dir" "$dir" >&2
        }
    done
}

inodeNumber() {
    ls -i "$1" | cut -d ' ' -f 1
}

validateHaveSiloAt() {
    ( cd "$r" && validateHaveSilo ) ||
        die "Invalid silo '$r'."
}

lsAllDedupCandidates() {
    for r in "${arg_repos[@]}"; do
        lsDedupCandidates "$r"
    done |
    sort -k 1.1,1.41 -s
}

lsDedupCandidates() {
    local abspath
    abspath=$( cd "$1" && cd "$(getSiloObjectDir)" && pwd )
    # '|| true' avoids pipefail without match.
    (
    lsDir "$abspath" |
    ( egrep '^[0-9a-f]{2}/[0-9a-f]{38}$' || true )
    ) |
    while read -r line; do
        printf '%s %s\n' "$line" "$abspath"
    done
}

validateNoStagedChanges() {
    no_staged_changes || die "You have staged changes."
}

validateNoUnstagedChanges() {
    no_unstaged_changes || die "You have unstaged changes."
}

no_staged_changes() {
    git diff-index --quiet --cached HEAD
}

no_unstaged_changes() {
    git diff-files --quiet
}

dieMissingPath() {
    local what="$1"
    msg="Missing path.  '${what}' requires a path, either on the command line or in 'remote.<remote>.silo${what}'."
    if test "${arg_remote}"; then
        msg="$msg  The first argument '${arg_remote}' was interpreted as a remote.  If you meant to use remote 'origin' and ${what} a path, separate the argument by a double dash: '-- ${arg_remote}'."
    fi
    die "${msg}"
}

die() {
    echo >&2 "Error (silo): $1"
    exit 1
}

echo_debug() {
    if test $opt_debug; then
        echo >&2 "$@"
    fi
}

main "$@"
