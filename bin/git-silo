#!/bin/bash
# vim: sw=4

set -o nounset -o errexit -o pipefail -o noglob

opt_debug=${GIT_SILO_DEBUG:-}

# Use 'C' locale to avoid unexpected effects of other locales.
export LC_ALL=C

# By default search for inodes in alternates only for files >50 MB.
cfg_searchInodeLimit() {
    getCfgSizeVarWithDefault "searchInodeLimit" "50M"
}

usage() {
    cat <<\EOF
git-silo init
git-silo add [--attr|--no-attr] [--] [<file>...]
git-silo checkout [--copy] [--link] [--placeholder] [--ignore-missing] \
    -- [<file>...]
git-silo status [-v|--verbose] [<path>...]
git-silo ls-tree <tree-ish>
git-silo push \
    [--dry-run] [-v|--verbose] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<url>|<remote> [<commit>]] \
    [--] [<path>... | config remote.<remote>.silopush]
git-silo fetch \
    [--dry-run] [-v|--verbose] \
    [--copy] [--link] [--placeholder] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<url>|<remote> [<commit>]] \
    [--] [<path>... | config remote.<remote>.silofetch]
git-silo gc [--gitattributes] [-f|--force] [-n <number>] [--dry-run] \
    [--no-tags]
git-silo purge [-f|--force] [--dry-run] [--no-strict-masterstore] [--] <path>...
git-silo pack [--all] [--keep-tip|--keep|--prune]
git-silo unpack [--keep-packs|--prune-packs] [--all] [--] [<path>...]
git-silo fsck
git-silo dedup <repo>...

  init              initialize silo.  Install clean and smudge git filters for
                    silo.  See also WILDCARD SETUP section.

  add               add untracked files for silo storage.  Creates hard link or
                    copy depending on value of 'silo.add'.  Tries to avoid
                    computing sha1s if 'silo.alternate' is set.  See
                    CONFIGURATION VARIABLES section.

  --attr|--no-attr  (default: --no-attr)
                    controls whether filter=silo gitattributes entries are
                    added if needed.  With --no-attr, gitattributes will not be
                    modified; files will only be added if the expected
                    attributes are already set (see WILDCARD SETUP section).
                    With --attr, the expected gitattributes will be
                    automatically added if necessary.

  checkout          replace placeholders with full content.

    --copy          copy files instead of using hard link.

    --link          replace checked-out copies with hard link.

    --placeholder   replace content with placeholders.

    --ignore-missing    silently ignore missing objects.

  status            print status of files stored in silo.

    -v|--verbose    include placeholder sha1s in output.

  ls-tree           recursively list sha1 placeholder and paths for <tree-ish>.

  push              push silo files.

    <url>|<remote>  url or git remote to push to (default: origin).

    <commit>        specific commit for which to push silo files (default: HEAD).

    <path>...       push will be limited to the given paths.  Default paths can
                    be configured with 'remote.<remote>.silopush'.  See PATHS
                    section.

  fetch             fetch and checkout silo files.  checkout is skipped if
                    <path> is not explicitly specified on the command line.

    <url>|<remote>  url or git remote to fetch from (default: origin).

    <commit>        specific commit for which to fetch silo files (default: HEAD).

    <path>...       fetch will be limited to the given paths.  Default paths
                    can be configured with 'remote.<remote>.silofetch'.  See
                    PATHS section.

    --copy          copy files instead of using hard link.

    --link          replace checked-out copies with a hard link.

    --placeholder   replace content with placeholders.

  common options for push and fetch

    --dry-run       print what would be transferred.

    -v|--verbose    print more information, e.g. skipped files.

    --include=<pat> include files whose 'silo' attribute matches glob-style
                    pattern <pat>.  See TRANSFER FILTERS section.

    --exclude=<pat> exclude files whose 'silo' attribute matches glob-styl
                    pattern <pat>.  See TRANSFER FILTERS section.

    --all           include all files.  The default is to skip files whose
                    gitattributes 'silo' contains an entry 'local'.  See
                    TRANSFER FILTERS section.

  gc                remove silo files that are not directly referenced by
                    HEAD, tags or tips of branches.

    --gitattributes Also remove unused entries from '.gitattributes' and create
                    a commit if '.gitattributes' has been changed.

    -f|--force      run gc even with unstaged changes.  Note that gc might
                    modify and commit '.gitattributes'.

    -n <number>     keep only objects reachable from the latest <number>
                    commits at each local head, including tags.  Note that
                    objects that are only reachable from a remote tracking
                    branch will be removed.

    --no-tags       remove objects that are reachable only via a tag.

    --dry-run       print only what would be removed.

  purge             replace files by placeholders and remove objects from silo.
                    Since this is a very destructive operation (comparable to
                    rm -rf), 'silo.ismasterstore=false' and the '--force' flag
                    are both required to actually remove files.  If
                    'silo.masterstore' is set, purge fill furthermore verify
                    that object are at the specified path before deleting them.

    <path>...       the files to remove.

    -f|--force      required to actually remove files.

    --dry-run       print only what would be removed.

    --no-strict-masterstore
                    If 'silo.masterstore' is set, purge by default refused to
                    proceed if any object is missing in the master store.  With
                    --no-strict-masterstore, purge deletes objects that are in
                    the masterstore and keeps objects that are not in the
                    masterstore.

  fsck              verify silo storage.

  pack              pack loose silo objects into 7z archives.  Use 'unpack' to
                    explicitly unpack objects, or set 'silo.autounpack=true' to
                    configure automatical unpacking of objects as needed.  The
                    size of the archives can be controlled with
                    'silo.packSizeLimit' (see CONFIGURATION VARIABLES section).

    --all           pack all loose objects.  The default is to leave objects
                    unpacked that are used by HEAD.

    --keep-tip      keep loose objects for HEAD; prune other loose objects that
                    have been packed.  This is the default.

    --keep          keep all loose objects.

    --prune         prune all loose objects that have been packed.

  unpack            unpack loose objects that are used by HEAD.

    <path>...       limit unpacking to these files (default: all).

    --keep-packs    keep packs.  This is the default.

    --prune-packs   prune packs that have been completely unpacked.

    --all           unpack all packed objects no matter whether they are used
                    by HEAD or not.

  dedup             create hard links between repositories.  Repositories listed
                    later get linked to repositories listed earlier.
                    Deduplication might be incomplete if silo objects are owned
                    by different users and the OS restricts creation of hard
                    links.  See KNOWN ISSUES section.

# WILDCARD SETUP

Git can be told to use git silo for all files of a certain type (based on a glob
pattern).  This avoids the need to explicitly call 'git silo add' when a file is
added for the first time; a simple 'git add' will directly use git silo.  For
example, the following line in '.gitattributes' tells git to handle all mov
files using git silo:

    *.mov filter=silo -text

# PATHS

You must always either provide a path on the command line or via the config
variables 'remote.<remote>.silopush' or 'remote.<remote>.silofetch'.  Otherwise
git-silo will refuse to transfer files to protect you from accidentally starting
large transfers.  Use '-- .' to explicitly transfer everything.

# TRANSFER FILTERS

The gitattribute 'silo' can be used to limit file transfer.  Per default, files
that carry the label 'local' are not transferred.  This can be useful to handle
less important files.  They can be tracked locally, for example on a scratch
filesystem, without transferring them to a central, probably more reliable but
perhaps space-limited, storage.

'--include=<pattern>' and '--exclude=<pattern>' can be used to select files.
Each entry of the comma-separated list in gitattribute 'silo' is matched against
the glob-style <pattern>.  '--all' includes all files.  Filter order matters.
The first match decides.

For example, with the following line in '.gitattributes'

    /path silo=foo,bar,local

'path' will be

    excluded by default
    included for '--all'
    included for '--include=ba*'
    excluded for '--exclude=fo* --include=ba*'

# CONFIGURATION VARIABLES

silo.add (default 'link'): Controls behaviour of 'git silo add'.  If set to
'link', a hard link is stored and the original file's permissions set to
read-only.  If set to 'copy', a copy will be stored.  Always storing a copy
might be useful if you want to keep the file open in another application, like
Word, and use 'git-silo add' repeatedly.  When creating a hard link, the file
permissions are changed to read-only, which might confuse applications like
Word.

silo.alternate (multiple allowed): Paths to git repos that contain git silos.
'git silo fetch' and 'git silo push' try to link files to an alternate silo
instead of fetching or pushing via ssh.  For 'fetch', 'silo.alternate' must be
set in the local repo.  For 'push', 'silo.alternate' must be set in the remote
repo.  If hard links can be used and 'git update-index --assume-unchanged-once'
is available (see patch in Git Silo repo), 'git silo add' tries to locate
inodes in the alternate silos to avoid computing sha1s.

silo.contentSizeLimit (default '10M'): If the content for a file that is stored
in silo is smaller than the limit or the limit is 0, the content will be used
during normal git operations, such as 'git checkout', 'git reset', or 'git
archive'.  Otherwise, placeholders will be used.  The suffixes 'K', 'M', 'G' can
be used.  'git silo checkout' always uses the content and will replace
placeholders in the working copy with the file content.  Note that placeholders
can be temporarily deactivated by using git's '-c' switch.  For example, the
following command will always create an archive with full content: 'git -c
silo.contentSizeLimit=0 archive HEAD >a.tar'

silo.packSizeLimit (default '50G'): The maximum size of a pack.  0 means no
limit.  The suffixes 'K', 'M', 'G' can be used.

silo.autounpack (default 'false'): If 'true', silo will try to unpack objects
if needed.

silo.ismasterstore (default 'true'): Unless set to 'false', some destructive
operations, such as 'purge', are not permitted.

silo.masterstore (default none): If set, 'purge' will check that objects are in
the silo at the specified path before deleting them.

GIT_SSH (environment variable): If set, git-silo will use the specified program
instead of ssh.

silo.sshtransport (default 'sshcat'): Configures how to fetch and push files
via ssh.  With 'sshcat', one ssh connection is used per file.

silo.searchInodeLimit (default: 50M): Minimal file size at which git silo tries
to locate an inode in alternates to avoid computing its sha1.  For large files,
it may be cheaper to search alternates; for small files it is usually quicker
to compute the sha1.

# KNOWN ISSUES

  - git-silo is designed and optimized towards handling relatively few large
    files.  The performance might be unexpectedly bad with many small files.
    If you have directory trees that contain many small files, you should
    consider packing them into a single tar before commiting them to git-silo.

  - ssh performance on Windows might be poor (only 1 MB/s on local network).
    The reason is that openssh, which comes with msysgit, suffers from the
    problem explained in

        http://support.microsoft.com/kb/823764

    As a workaround, install PuTTY and tell git to use it (set GIT_SSH, use
    pageant).

  - git might fail with mmap out-of-memory on Windows.  Git on Windows is a
    32-bit executable, which fails for large files in some situations.  There is
    no known workaround.

  - If creation of hard links between different users is restricted, some
    operations might report warnings (like 'dedup') or copy data as a fall back
    ('fetch' from local filesystem).  Since Linux 3.6, the restrictions can be
    controlled with '/proc/sys/fs/protected_hardlinks' (see proc(5)).

  - Readonly permissions on Windows do not work as expected for hard links.  A
    file unexpectedly becomes writable when a hard link to it is deleted,
    because deleting hard links to read-only files is impossible.  See

        http://msdn.microsoft.com/en-us/library/windows/desktop/aa365006(v=vs.85).aspx

    As a workaround, git-silo verifies permissions whenever it needs a stored
    object and fixes them the read-only if needed.  It is yet unclear whether
    this is good enough in practice or whether there are conditions when a hard
    link is writable and git modifies a stored object that should be immutable.

  - On SunOS, the following GNU tools are required: ggrep, gegrep, gsed, gfind,
    gsort, gxargs.

EOF
}

main() {
    argparse "$@"
    setup_arch
    validateGitVersion

    cmd_$arg_cmd
}

argparse() {
    arg_cmd=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if test "$arg_cmd"; then
                die "Wrong number of arguments"
            else
                validateCmd "$1"
                arg_cmd="$1"
                shift
                argparse_$arg_cmd "$@"
                return
            fi
            ;;
        esac
    done
    test "$arg_cmd" || die "Missing command."
}

argparse_init() {
    argparse_default "$@"
}

argparse_gc() {
    opt_force=
    opt_n=
    opt_dry_run=
    opt_tags=t
    opt_gitattributes=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --gitattributes)
            opt_gitattributes=t
            shift
            ;;
        --no-tags)
            opt_tags=
            shift
            ;;
        -n)
            shift
            [ $# -ge 1 ] || die "-n must be followed by number."
            opt_n=$1
            grep -q '[1-9][0-9]*' <<<"${opt_n}" ||
                die "-n must be followed by a number >= 1."
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_fsck() {
    argparse_default "$@"
}

argparse_pack() {
    opt_keep=tip
    opt_all=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --keep)
            opt_keep=all
            shift
            ;;
        --keep-tip)
            opt_keep=tip
            shift
            ;;
        --prune)
            opt_keep=unpacked
            shift
            ;;
        --all)
            opt_all=t
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_unpack() {
    arg_pathspec=( . )
    opt_keep_packs=t
    opt_all=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --keep-packs)
            opt_keep_packs=t
            shift
            ;;
        --prune-packs)
            opt_keep_packs=
            shift
            ;;
        --all)
            opt_all=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_dedup() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            break
            ;;
        esac
    done
    [ $# -ge 1 ] || die "Wrong number of arguments (expect at least two paths)."
    arg_repos=( "$@" )
}

argparse_purge() {
    opt_force=
    opt_dry_run=
    opt_strict_masterstore=t
    # Empty `arg_pathspec` array will be handled in in `cmd_purge`.
    arg_pathspec=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --no-strict-masterstore)
            opt_strict_masterstore=
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            break
            ;;
        esac
    done
}

argparse_default() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_filter_smudge() {
    argparse_filter "$@"
}

argparse_filter_clean() {
    argparse_filter "$@"
}

argparse_filter() {
    (( $# == 1 )) || die "Missing <path>."
    arg_file="${1}"
    echo "Warning: using old-style git-silo filter, rerun 'git-silo init' to upgrade filters." >&2
}

argparse_add() {
    arg_pathspec=( . )
    opt_attr=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --attr)
            opt_attr=t
            shift
            ;;
        --no-attr)
            opt_attr=
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_checkout() {
    arg_pathspec=( . )
    opt_copy=
    opt_link=
    opt_placeholder=
    opt_ignore_missing=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --copy)
            opt_copy=t
            shift
            ;;
        --link)
            opt_link=t
            shift
            ;;
        --placeholder)
            opt_placeholder=t
            shift
            ;;
        --ignore-missing)
            opt_ignore_missing=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_status() {
    arg_pathspec=( . )
    opt_verbose=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -v|--verbose)
            opt_verbose=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_ls-tree() {
    arg_commit=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            break
            ;;
        esac
    done
    [ $# -eq 1 ] || die "Wrong number of args."
    arg_commit="$1"
}

argparse_pathspec() {
    arg_pathspec=( . )
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_fetch() {
    local arg dummy
    opt_dry_run=
    opt_verbose=
    # Empty `arg_pathspec` will be handled in in `cmd_fetch`.
    arg_pathspec=
    arg_remote=
    arg_commit=
    arg_filter=()
    opt_copy=
    opt_link=
    opt_placeholder=
    opt_ignore_missing=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --dry-run)
            opt_dry_run=--dry-run
            shift
            ;;
        -v|--verbose)
            opt_verbose=t
            shift
            ;;
        --include=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "+ $arg" )
            ;;
        --exclude=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "- $arg" )
            ;;
        --all)
            arg_filter=( '+ *' )
            shift
            ;;
        --copy)
            opt_copy=t
            shift
            ;;
        --link)
            opt_link=t
            shift
            ;;
        --placeholder)
            opt_placeholder=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if ! test "$arg_remote"; then
                arg_remote="$1"
                shift
            elif ! test "${arg_commit}"; then
                arg_commit=$(git rev-parse --verify "$1^{commit}") ||
                    die "Invalid commit '$1'."
                shift
            else
                arg_pathspec=( "$@" )
                break
            fi
            ;;
        esac
    done
    (( ${#arg_filter[@]} )) || arg_filter=( '- local' )
}

argparse_push() {
    local arg dummy
    opt_dry_run=
    opt_verbose=
    # Empty `arg_pathspec` will be handled in in `cmd_push`.
    arg_pathspec=
    arg_remote=
    arg_commit=
    arg_filter=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --dry-run)
            opt_dry_run=--dry-run
            shift
            ;;
        -v|--verbose)
            opt_verbose=t
            shift
            ;;
        --include=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "+ $arg" )
            ;;
        --exclude=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "- $arg" )
            ;;
        --all)
            arg_filter=( '+ *' )
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if ! test "$arg_remote"; then
                arg_remote="$1"
                shift
            elif ! test "${arg_commit}"; then
                arg_commit=$(git rev-parse --verify "$1^{commit}") ||
                    die "Invalid commit '$1'."
                shift
            else
                arg_pathspec=( "$@" )
                break
            fi
            ;;
        esac
    done
    (( ${#arg_filter[@]} )) || arg_filter=( '- local' )
}

validateGitVersion() {
    local version major minor
    version=$(git version)
    version=$(cut -d ' ' -f 3 <<<"$version")
    major=$(cut -d . -f 1 <<<"$version")
    minor=$(cut -d . -f 2 <<<"$version")
    if [ $major -lt 2 ] && [ $minor -lt 9 ]; then
        die "git version too low (require at least version 1.9)."
    fi
    if ( git update-index -h 2>&1 || true ) | grep -q assume-unchanged-once; then
        cfg_git_has_assume_unchanged_once=t
    else
        cfg_git_has_assume_unchanged_once=
    fi
}

validateCmd() {
    case "$1" in
    filter_smudge|filter_clean|add|status|push|fetch|init|checkout|gc|dedup|fsck|pack|unpack|purge|ls-tree)
        return 0
        ;;
    *)
        die "Invalid command '$1'."
        ;;
    esac
}

cmd_init() {
    local gitdir siloprg
    gitdir=$(git rev-parse --git-dir)
    echo "Initializing silo in '$gitdir'."
    mkdir -p "$gitdir/silo/objects"
    if isSharedDir "$gitdir/objects"; then
        echo "Using shared permissions."
        find "$gitdir/silo" -type d -print0 | xargs -0 chmod g+ws || {
            echo >&2 "Warning: shared permissions might be incompletely initialized (see above)."
        }
    fi
    if ! isBareRepo; then
        # git-silo uses hard link operations, which modify ctime.  Tell git to
        # ignore ctime.
        git config core.trustctime false
        configFilters
    fi
}

configFilters() {
    local silobindir
    silobindir=$(getSiloBinDir)
    mkdir -p "${silobindir}"
    genprgFilterClean >"${silobindir}/clean"
    chmod a+x "${silobindir}/clean"
    genprgFilterSmudge >"${silobindir}/smudge"
    chmod a+x "${silobindir}/smudge"
    # The leading space is necessary to avoid msys path mangling.
    git config filter.silo.clean ' "$(git rev-parse --git-dir)/silo/bin/clean" %f'
    git config filter.silo.smudge ' "$(git rev-parse --git-dir)/silo/bin/smudge" %f'
    git config filter.silo.required true
}

isBareRepo() {
    [ $(git rev-parse --is-bare-repository) = "true" ]
}

cmd_filter_clean() {
    validateHaveSilo
    if isSha1PlaceholderFile "$arg_file"; then
        tr -d '\r'
    else
        computeSha1AndStoreContentInSilo
    fi
}

genprgFilterClean() {
    genprgShbang
    genprgMainClean
    genprgFunctions \
        cmd_filter_clean \
        validateHaveSilo \
        getSiloObjectDir \
        getSiloDir \
        isSha1PlaceholderFile \
        fileSize \
        computeSha1AndStoreContentInSilo \
        computeSha1 \
        mkdirWithParentsPermissions \
        isSharedDir \
        cfg_silo_add \
        setup_arch \
        setup_arch_SunOS \
        setup_arch_msysgit \
        die
    genprgCallMain
}

genprgFilterSmudge() {
    genprgShbang
    genprgMainSmudge
    genprgFunctions \
        cmd_filter_smudge \
        cfg_contentSizeLimit \
        getCfgSizeVarWithDefault \
        validSha1 \
        getSiloObjectDir \
        getSiloDir \
        fileSize \
        setup_arch \
        setup_arch_SunOS \
        setup_arch_msysgit \
        die
    genprgCallMain
}

genprgShbang() {
    cat <<\EOF
#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail
set -o noglob

EOF
}

genprgMainClean() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    setup_arch
    cmd_filter_clean
}

EOF
}

genprgMainSmudge() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    setup_arch
    cmd_filter_smudge
}

EOF
}

genprgCallMain() {
    cat <<\EOF
main "$@"
EOF
}

genprgFunctions() {
    for f in "$@"; do
        declare -f $f
        echo
    done
}

computeSha1AndStoreContentInSilo() {
    local objdir sha1 subdir objfile
    objdir=$(getSiloObjectDir)
    sha1=$(computeSha1) || die "Failed to compute sha1."
    subdir=$objdir/${sha1:0:2}
    objfile=$subdir/${sha1:2}
    if ! [ -e "$objfile" ]; then
        mkdirWithParentsPermissions "$subdir"
        case $(cfg_silo_add) in
        link)
            ln "$arg_file" "$objfile" >/dev/null 2>&1 ||
                cp "$arg_file" "$objfile"
            [ -w "${objfile}" ] &&
                chmod a-w "$objfile" || true
            ;;
        copy)
            cp "$arg_file" "$objfile"
            [ -w "${objfile}" ] &&
                chmod a-w "$objfile" || true
            ;;
        esac
    fi
    printf '%s\n' $sha1
}

cfg_silo_add() {
    local option
    option=$(git config silo.add) || option=link
    case $option in
    link|copy)
        ;;  # OK
    *)
        printf "Warning: invalid option silo.add = '%s'; using 'link'.\n" "$option" >&2
        option=link
        ;;
    esac
    echo $option
}

cfg_ismasterstore() {
    git config silo.ismasterstore || echo "true"
}

cmd_filter_smudge() {
    local objdir sha1
    IFS= read -r -n 41 sha1
    validSha1 "$sha1" || die "Invalid input; expected sha1: $arg_file"
    IFS= read -r -n 1 dummy && die "Input too large."
    objdir="$(getSiloObjectDir)"
    objfile="${objdir}/${sha1:0:2}/${sha1:2}"
    if [ -e "${objfile}" ]; then
        # Try to set to read-only to contain Windows madness that requires to
        # change files to writable when deleting a hardlink.
        [ -w "${objfile}" ] &&
            chmod a-w "${objfile}" || true
        local contentSizeLimit=$(cfg_contentSizeLimit)
        if [ $contentSizeLimit -eq 0 ] ||
            [ $(fileSize "${objfile}") -lt $contentSizeLimit ]; then
            cat "${objfile}"
        else
            printf >&2 "using placeholder: %s\n" "${arg_file}"
            printf '%s\n' ${sha1}
        fi
    else
        printf >&2 "missing silo content: %s\n" "${arg_file}"
        printf '%s\n' "${sha1}"
    fi
}

cfg_contentSizeLimit() {
    getCfgSizeVarWithDefault "contentSizeLimit" "10M"
}

cfg_packSizeLimit() {
    getCfgSizeVarWithDefault "packSizeLimit" "50G"
}

getCfgSizeVarWithDefault() {
    local var="$1"
    local default="$2"
    local size
    size=$(git config silo.${var}) || size=${default}
    if ! egrep -q '^(0|[1-9][0-9]*)[kKmMgG]?$' <<<"${size}"; then
        printf >&2 \
            "Warning: invalid silo.%s=%s, using default.\n" "${var}" "${size}"
        size=${default}
    fi
    # Expand potential suffix and compute size.
    size=$(sed \
        -e 's/[kK]/*1024/' -e 's/[mM]/*1048576/' -e 's/[gG]/*1073741824/' \
        <<<"${size}")
    printf "%d" $(( ${size} ))
}

# `fileSize()` determines the size for large files on Mac, Linux and msysgit.
# Because the output formats of BSD find and GNU find differ, sed is used to
# remove all leading characters before the permission field, assuming that "$1"
# is an ordinary file (it won't work for a symlink).
#
# find is used instead of ls, because msysgit's ls reports the wrong size for
# large files.
fileSize() {
    find "$1" -ls | sed -e 's/  */ /g' -e 's/^[^-]*-/-/' | cut -d ' ' -f 5
}

validateHaveSilo() {
    local objdir
    objdir=$(getSiloObjectDir)
    [ -d "$objdir" ] || die "Missing silo '$objdir'; run 'git-silo init'."
}

getSiloDir() {
    local silodir
    silodir="$(git rev-parse --git-dir)"
    silodir="$(cd "${silodir}" && pwd)"
    silodir="${silodir}/silo"
    printf '%s' "${silodir}"
}

getSiloBinDir() {
    printf '%s/%s' "$(getSiloDir)" "bin"
}

getSiloObjectDir() {
    printf '%s/%s' "$(getSiloDir)" "objects"
}

getSiloPackDir() {
    printf '%s/%s' "$(getSiloDir)" "packs"
}

mktempSiloDir() {
    local tmp
    tmp="$(getSiloDir)/tmp$$"
    mkdir "${tmp}" ||
        die "Failed to create tmpdir '${tmp}'."
    printf '%s' "${tmp}"
}

computeSha1() {
    openssl sha1 | cut -d ' ' -f 2 | egrep '^[0-9a-f]{40}$'
}

validSha1() {
    egrep -q '^[0-9a-f]{40}$' <<< "$1"
}

# Files should not end in CRLF, because .gitattributes sets -text on
# placeholders.  In case, however, the file get checked out with CRLF, it should
# be accepted as a placeholder.
isSha1PlaceholderFile() {
    [ -f "$1" ] || return 1
    local size=$(fileSize "$1")
    if [ -z "${size}" ]; then
        printf >&2 "Warning: Failed to determine file size for '%s'; assuming it is not a sha1 placeholder.\n" "$1"
        return 1
    fi
    [ $size -eq 41 -o $size -eq 42 ] &&
    egrep -q $'^[0-9a-f]{40}\r?$' "$1"
}

cmd_add() {
    local objdir
    local prefix

    validateHaveSilo
    objdir="$(getSiloObjectDir)"
    prefix="$(git rev-parse --show-prefix)"
    searchInodeLimit=$(cfg_searchInodeLimit)

    while read -r headsha1 qpath; do
        [ -z "${qpath}" ] && continue
        path="$(unquotePath "${qpath}")"
        if test ${opt_attr}; then
            updateGitattributes "${path}"
            addFile ${headsha1} "${path}"
        elif hasGitSiloAttributes "${path}"; then
            addFile ${headsha1} "${path}"
        else
            printf >&2 "Warning: missing silo gitattributes 'filter=silo -text', ignoring %s\n" "${path}"
        fi
    done <<< "$(
        lsUntrackedFiles;
        lsTrackedFilesForAdd
    )"
}

# Try to avoid computing a sha1 by checking whether the local silo has the
# inode for the head sha1.  If not, try to locate the inode in one of the
# alternates and inject a match directly into the index.  Try these
# optimizations only if a hardlink can be used.
addFile() {
    local headsha1="$1"
    local path="$2"
    local sha1

    if test ${cfg_git_has_assume_unchanged_once} &&
        [ -f "${path}" ] &&
        [ $(linkCount "$path") -gt 1 ]; then
        if isSameInodeInSilo ${headsha1} "${path}"; then
            echo_debug "Head matches ${headsha1} for '${path}'."
            git update-index --assume-unchanged-once "${path}"
            return 0
        elif [ $(fileSize "${path}") -ge ${searchInodeLimit} ] &&
                sha1=$(findSha1InAlternates "${path}"); then
            echo_debug "Found silo.alternate ${sha1} for '${path}'."
            linkFileInSilo ${sha1} "${path}"
            local blob
            local mode
            blob=$(printf '%s\n' "${sha1}" | git hash-object --stdin -w)
            if [ -x "${path}" ]; then
                mode=100755
            else
                mode=100644
            fi
            git update-index --add --cacheinfo "${mode},${blob},${prefix}${path}"
            git update-index --assume-unchanged-once "${path}"
            return 0
        else
            echo_debug "Did not find silo.alternate sha1 for '${path}'."
        fi
    fi

    if [ -e "${path}" ]; then
        git add -- "${path}"
    else
        # Ignore potential errors when calling add on a deleted file twice.
        # Git would complain that pathspec does not match a file.
        git add -- "${path}" 2>/dev/null || true
    fi
}

linkFileInSilo() {
    local sha1="$1"
    local file="$2"
    local subdir objfile
    subdir="$objdir/${sha1:0:2}"
    objfile="$subdir/${sha1:2}"
    [ -e "$objfile" ] && return
    mkdirWithParentsPermissions "$subdir"
    ln "${file}" "${objfile}" >/dev/null 2>&1 || cp "${file}" "${objfile}"
    chmod a-w "${objfile}"
}

isSameInodeInSilo() {
    local sha1="$1"
    local path="$2"
    local objpath="${objdir}/$(sha1AsObjectPath "${sha1}")"
    [ -f "${objpath}" ] || return 1
    [ $(inodeNumber "${objpath}") -eq $(inodeNumber "${path}") ]
}

findSha1InAlternates() {
    local path="$1"
    while IFS= read -r alt; do
        [ -z "${alt}" ] && continue
        alt=$(resolveAlternateSiloDir "${alt}" 2>/dev/null) || continue
        [ -d "${alt}" ] || continue
        findSha1ForInode "${alt}" "${path}" && return 0
    done <<<"$(git config --get-all silo.alternate || true)"
    return 1
}

resolveAlternateSiloDir() {
    (
        cd "$(git rev-parse --show-toplevel)" &&
        cd "$1" &&
        getSiloObjectDir
    )
}

# Find prints at most one match: ./xx/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
# The sha1 is char 3-4,6-43.
findSha1ForInode() {
    local alt="$1"
    local path="$2"
    local inum
    inum=$(inodeNumber "${path}")
    (
        cd "${alt}" &&
        find . -type f -inum ${inum}
    ) | cut -b 3-4,6-43 | egrep '^[0-9a-f]{40}$'
}

# List committed files if HEAD is valid.
lsTrackedFilesForAdd() {
    git rev-parse -q --verify HEAD >/dev/null || return 0
    lsSiloTracked "${arg_pathspec[@]}"
}

cmd_checkout() {
    if test ${opt_placeholder}; then
        cmd_checkout_placeholder
        return
    fi
    local sha1 qpath path objdir objfile
    validateHaveSilo
    objdir=$(getSiloObjectDir)
    fixPermissions
    tryAutoUnpackForCheckout
    local haveErr=
    while read -r sha1 qpath; do
        [ -z "$qpath" ] && continue
        path="$(unquotePath "${qpath}")"
        objfile=$objdir/$(sha1AsObjectPath "${sha1}")
        if ! test -e "$objfile"; then
            if test ${opt_ignore_missing}; then
                true  # Silently ignore missing.
            elif hasSiloAttrLabel 'local' "${path}"; then
                printf >&2 "Notice: missing silo content with label 'local': %s\n" "$path"
            else
                printf >&2 "missing silo content: %s\n" "$path"
                haveErr=t
            fi
            continue
        fi
        if ! hasGitSiloAttributes "${path}"; then
            printf >&2 "Warning: missing silo gitattributes 'filter=silo -text', keeping placeholder: %s\n" "${path}"
            continue
        fi
        mkdir -p "$(dirname "$path")"
        (
            ! test $opt_copy &&
            xbitAllowsLink "${objfile}" "${path}" &&
            rm -f "$path" &&
            ln "$objfile" "$path" >/dev/null 2>&1 && (
                ! test -w "$path" ||
                chmod a-w "$path" >/dev/null 2>&1 || (
                    test $opt_link &&
                    echo "Warning: failed to set read-only permissions, falling back to copy '$path'." >&2 &&
                    false
                )
            ) &&
            printf "Linking %s %s\n" "${sha1}" "${path}"
        ) || (
            rm -f "$path" &&
            cp "$objfile" "$path" && (
                if gitExpectsXbit "${path}"; then
                    chmod a+x "${path}"
                else
                    chmod a-x "${path}"
                fi
            )
            chmod u+w "$path" &&
            printf "Copying %s %s\n" "${sha1}" "${path}"
        ) || {
            printf >&2 "Failed to copy '%s' to '%s'.\n" "$objfile" "$path"
            haveErr=t
            continue
        }
        # Update index, so that 'git status' is clean.
        if test ${cfg_git_has_assume_unchanged_once}; then
            git update-index --assume-unchanged-once -- "${path}"
        else
            git add -u -- "${path}"
        fi
    done <<< "$(lsNeedsCheckout)"
    test $haveErr && die "There have been problems during silo checkout (see above)."
    true
}

cmd_checkout_placeholder() {
    while read -r sha1 qpath; do
        [ -z "${qpath}" ] && continue
        path="$(unquotePath "${qpath}")"
        [ -e "${path}" ] && isSha1PlaceholderFile "${path}" && continue
        printf "Placeholder %s %s\n" "${sha1}" "${path}"
        rm -f "${path}"
        printf '%s\n' "${sha1}" >"${path}"
        gitExpectsXbit "${path}" && chmod a+x "${path}"
        git add -u -- "${path}"
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

# Try to set stored objects that are writable to read-only to contain Windows
# hard link madness.
fixPermissions() {
    while read -r sha1 path; do
        [ -z "$path" ] && continue
        local objfile="${objdir}/$(sha1AsObjectPath ${sha1})"
        if [ -w "${objfile}" ]; then
            chmod a-w "${objfile}" || true
        fi
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

tryAutoUnpackForCheckout() {
    lsNeedsCheckout |
    cut -d ' ' -f 1 |
    tryAutoUnpackInDir '.'
}

lsNeedsCheckout() {
    local sha1 qpath path
    while read -r sha1 qpath; do
        [ -z "${qpath}" ] && continue
        path="$(unquotePath "${qpath}")"
        pathNeedsCheckout ${sha1} "${path}" || continue
        printf '%s %s\n' "${sha1}" "${qpath}"
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

# Should checkout if
#
#  - path doesn't exist.
#  - path is a placeholder.
#  - copy is requested and path is linked.
#  - link is requested and path is not linked to object in silodir.
#
pathNeedsCheckout() {
    ! [ -e "$path" ] && return 0
    isSha1PlaceholderFile "$path" && return 0
    ( test $opt_copy && [ $(linkCount "$path") -gt 1 ] ) && return 0
    if test $opt_link; then
        [ $(linkCount "$path") -eq 1 ] && return 0
        local objfile="${objdir}/$(sha1AsObjectPath ${sha1})"
        if [ -f "${objfile}" ]; then
            [ "$(inodeNumber "${objfile}")" = "$(inodeNumber "${path}")" ] ||
                return 0
        fi
    fi
    false
}

xbitAllowsLink() {
    local src=$1
    local dest=$2
    [ -f "${src}" ] || return 1
    if [ "$(git config core.filemode)" == 'false' ]; then
        return 0
    fi
    if gitExpectsXbit "${dest}"; then
        [ "$(ls -l "${src}" | cut -b 4)" == 'x' ] && return 0
    else
        [ "$(ls -l "${src}" | cut -b 4)" != 'x' ] && return 0
    fi
    printf >&2 "Warning: can't use hardlink, because x-bits don't match; falling back to copy '%s'.\n" "${2}"
    return 1
}

gitExpectsXbit() {
    [ "$(git ls-files --stage -- "${1}" | cut -b 4)" == "7" ]
}

linkCount() {
    ls -l "$1" | sed -e 's/  */ /' | cut -d ' ' -f 2
}

lsUntrackedFiles() {
    git ls-files --exclude-standard --exclude=.git* -o -- "${arg_pathspec[@]}" |
    sed -e 's/^/0000000000000000000000000000000000000000 /'
}

updateGitattributes() {
    local p dir base gitignore
    p="$1"
    dir="$(dirname "$p")"
    base="$(basename "$p")"
    gitattributes="$dir/.gitattributes"
    tmpfile="$gitattributes-tmp$$"

    if hasGitSiloAttributes "${p}"; then
        return 0
    fi

    local endl=$(getWorkingCopyEndl)
    [ -e "$gitattributes" ] || touch "$gitattributes"
    ( printf '/%s filter=silo -text'$endl "$(escapeSpacesForGitattributes "$base")" && cat "$gitattributes") |
        sort -u >"$tmpfile"
    mv "$tmpfile" "$gitattributes"
    git add "$gitattributes"
}

hasGitSiloAttributes() {
    local p="${1}"
    [[ $(getAttrValue text "${p}") == "unset" ]] &&
        [[ $(getAttrValue filter "${p}") == "silo" ]]
}

getAttrValue() {
    local attr="${1}"
    local path="${2}"
    # check-attr's output is '<path> COLON SP <attribute> COLON SP <info> LF'.
    # Remove up to `COLON SP <attribute> COLON SP` to handle colons in paths.
    git check-attr "${attr}" "${path}" | sed -e "s/^.*: ${attr}: //"
}

getWorkingCopyEndl() {
    local cfg_autocrlf
    if cfg_autocrlf=$(git config core.autocrlf) &&
            [ $cfg_autocrlf = 'true' ]; then
        printf '\\r\\n'
    else
        printf '\\n'
    fi
}

# .gitattributes doesn't support spaces, so replace them by ?.
escapeSpacesForGitattributes() {
    tr ' ' '?' <<< "$1"
}

cmd_status() {
    validateHaveSilo
    local sha1 qpath path
    while read -r sha1 qpath; do
        [ "${qpath}" = "" ] && continue
        path="$(unquotePath "${qpath}")"
        if isSha1PlaceholderFile "${path}"; then
            printf 'placeholder '
        else
            printf 'content     '
        fi
        test ${opt_verbose} && printf '%s ' "${sha1}"
        printf '%s\n' "${qpath}"
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

cmd_ls-tree() {
    lsSiloTracked
}

# Use git cat-file in batch mode to avoid spawning many git processes.
#
# Use a start token that is longer than the content length of 41 chars to sync
# the batch stream after each object in order to handle any object content.
#
# Use grep to finally accept valid sha1 placeholders and reject other content.
lsSiloTracked() {
    local nl=$'\n'
    local starttok='---------------------------------------------'
    local perm ty gitsha1 size qpath sha1
    lsTree "$@" |
    while read -r perm ty gitsha1 size qpath; do
        [ -z "$qpath" ] && continue
        [ "${perm:0:3}" = "100" ] || continue
        [ "$size" = 41 ] || continue
        printf '%s %s\n' "${gitsha1}" "${qpath}"
    done |
    git cat-file --batch="${starttok}${nl}%(rest)" |
    while seekToStartTok && IFS= read -r qpath && IFS= read -r sha1; do
        [ -z "${qpath}" ] && continue
        [ -z "${sha1}" ] && continue
        printf '%s %s\n' "${sha1}" "${qpath}"
    done |
    ( egrep '^[0-9a-f]{40}' || true )
}

# Use starttok from caller.
seekToStartTok() {
    local tok
    while IFS= read -r tok; do
        [ "${tok}" = "${starttok}" ] && return 0
    done
    false
}

lsTree() {
    local commit=${arg_commit:-HEAD}
    git ls-tree -rl "${commit}" -- "$@"
}

# ls-tree quotes paths if they contain special characters.  A quoted path
# starts with a double quote and contains \... sequences that can be converted
# with printf's special format specifier '%b'.  Eval is used, because the path
# string itself contains double quotes.
unquotePath() {
    local p="$1"
    if [ "${p:0:1}" = '"' ]; then
        eval printf '%b' ${p}
    else
        printf '%s' "${p}"
    fi
}

cmd_push() {
    local todo
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    elif isRemoteName "${remote}"; then
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silopush) ) ||
            pathspec=()
        unset IFS
    else
        pathspec=()
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "push"
    validateHaveSilo
    local url silourl transport
    url=$(getRemoteUrl)
    silourl=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Pushing silo to $url"
    todo="$(
        lsSiloTracked "${pathspec[@]}" |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        transport_${transport}_push_prepush "${url}" "${silourl}"
    )"
    if [ -z "${todo}" ]; then
        echo 'Everything up-to-date.'
        exit 0
    fi
    ( grep '^MISSING' <<<"${todo}" || true ) | cut -d ' ' -f 2 |
        selectSha1sToUnpack |
        tryAutoUnpackInDir '.'
    transport_${transport}_push "${silourl}" <<<"${todo}"
}

selectSha1sToUnpack() {
    local sha1 objdir
    objdir="$(getSiloObjectDir)"
    while read -r sha1; do
        [ "${sha1}" = "" ] && continue
        p=$(sha1AsObjectPath "${sha1}")
        [ -f "${objdir}/${p}" ] && continue
        printf '%s\n' "$sha1"
    done
}

cmd_fetch() {
    local todo
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    elif isRemoteName "${remote}"; then
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silofetch) ) ||
            pathspec=()
        unset IFS
    else
        pathspec=()
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "fetch"
    validateHaveSilo
    local url transport
    url=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Fetching silo from $url"
    # selectMissingSha1Paths before filterSiloAttr to optimize for case that
    # nothing is missing.
    todo="$(
        lsSiloTracked "${pathspec[@]}" |
        selectMissingSha1Paths |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        selectMissingSha1sWithPacked
    )"
    if [ -z "${todo}" ]; then
        echo 'Everything up-to-date.'
    else
        transport_${transport}_prefetch "${url}" <<<"${todo}"
        sha1sAsObjectPaths <<<"${todo}" |
            transport_${transport}_fetch "$url"
    fi

    # Checkout fetched files unless --dry-run or missing pathspec.
    test ${opt_dry_run} && return 0
    test "$arg_pathspec" || return 0
    cmd_checkout
}

# transport_sshcat
transport_sshcat_fetch() {
    local objdir url dir objPathMap
    local url_host url_dir psha1 tmp remoteObjdir
    url=$1
    read url_host url_dir <<< "$(parseUrl "$url")"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    objdir=$(getSiloObjectDir)
    remoteObjs=$(lsRemoteObjects "$url_host" "${url_dir}")
    remoteObjdir="${url_dir}/objects"
    local alternates="$(resolveAlternates)"
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        if ! findLineIn "$p" "$remoteObjs"; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"
        if test $opt_dry_run; then
            continue
        fi
        dir="$(dirname "$p")"
        mkdirWithParentsPermissions "$objdir/$dir"
        tryLinkToAlternate "${p}" && continue
        tmp="${objdir}/${p}-tmp"
        rm -f "${tmp}"
        exec_ssh </dev/null "${url_host}" "cat '${remoteObjdir}/${p}'" >"${tmp}" ||
            die "Failed to copy '$p'."
        exec_ssh </dev/null "${url_host}" "test -x '${remoteObjdir}/${p}'" &&
            chmod a+x "${tmp}"
        chmod a-w "${tmp}"
        psha1=${p//\//}
        if [ $(computeSha1 <"${tmp}") != "${psha1}" ]; then
            rm -f "${tmp}"
            die "Checksum mismatch."
        fi
        mv "${tmp}" "$objdir/$p"
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

# Resolve alternates to absolute paths (to silo object dir).
resolveAlternates() {
    while IFS= read -r alt; do
        [ -z "${alt}" ] && continue
        resolveAlternate "${alt}" 2>/dev/null ||
            printf >&2 "Warning: failed to resolve alternate '%s' in '%s'.\n" \
                "${alt}" "$(pwd)"
    done <<<"$(git config --get-all silo.alternate || true)"
}

resolveAlternate() {
    local alt="$1"
    (
        if [ $(git rev-parse --is-inside-work-tree) = "true" ]; then
            cd "$(git rev-parse --show-toplevel)"
        elif [ $(git rev-parse --is-inside-git-dir) = "true" ]; then
            cd "$(git rev-parse --git-dir)"
        else
            printf >&2 "Error: neither inside work tree nor inside git dir."
            return 1
        fi &&
        cd "${alt}" &&
        cd "$(getSiloObjectDir)" &&
        pwd
    )
}

# Uses `alternates` and `objdir` from caller.
tryLinkToAlternate() {
    local p="$1"
    local src
    while IFS= read -r alt; do
        [ -z "${alt}" ] && continue
        src="${alt}/${p}"
        [ -f "${src}" ] || continue
        ln "${src}" "${objdir}/${p}" || continue
        echo "  linked to alternate ${alt}."
        return 0
    done <<<"${alternates}"
    return 1
}

transport_sshcat_push_prepush() {
    local url="$1"
    local silourl="$2"
    local url_host url_dir
    read url_host url_dir <<< "$(parseUrl "$url")"
    local silourl_host silourl_dir
    read silourl_host silourl_dir <<< "$(parseUrl "$silourl")"
    local prgpath
    prgpath=$(genprgRemotePrepush "${url_dir}" "${silourl_dir}" |
        exec_ssh "${url_host}" bash -c \
            "'p=\$(mktemp /tmp/git-silo-receive.XXXXXX); cat >\$p; echo \$p'")
    exec_ssh "${url_host}" "bash '${prgpath}'" ||
        die "Failed to prepare push."
}

genprgRemotePrepush() {
    genprgShbang
    genprgSelfDestroy
    genprgFunctions \
        sha1AsObjectPath \
        catPackLsts \
        findLineIn \
        transport_localcp_push_prepush \
        tryPrepushLinkToAlternate \
        mkdirWithParentsPermissions \
        isSharedDir \
        resolveAlternates \
        resolveAlternate \
        getSiloObjectDir \
        getSiloDir \
        setup_arch \
        setup_arch_SunOS \
        setup_arch_msysgit \
        die
    genprgRemotePrepushReceiveImpl "$@"
}

genprgRemotePrepushReceiveImpl() {
    cat <<EOF
setup_arch
transport_localcp_push_prepush '$1' '$2'
EOF
}

transport_sshcat_push() {
    local objdir url objPathMap url_host url_dir remotep
    url=$1
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    objdir=$(getSiloObjectDir)
    read url_host url_dir <<< "$(parseUrl "$url")"
    while read what p; do
        [ -z "$p" ] && continue
        p=$(sha1AsObjectPath "$p")
        if [ "${what}" = "LINKED" ]; then
            printSyncInfo "Linked to alternate at remote" "$p" "$objPathMap" >&2
            continue
        fi
        if ! [ -f "$objdir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            continue
        fi
        xbit=
        if [ -x "${objdir}/${p}" ] && [ "$(git config core.filemode)" == 'true' ]; then
             xbit=yes
        fi

        # Write paths to program to protect them from msysgit path mangling.
        # Pass prgpath together with bash in a single string to protect prgpath
        # from mangling.
        local prgpath
        prgpath=$(genprgRemoteCatReceive "${url_dir}" "${p}" "${xbit}" |
            exec_ssh "${url_host}" bash -c \
                "'p=\$(mktemp /tmp/git-silo-receive.XXXXXX); cat >\$p; echo \$p'")
        cat "${objdir}/${p}" |
            exec_ssh "${url_host}" "bash '${prgpath}'" ||
                die "Failed to copy '$p'."
    done
}

genprgRemoteCatReceive() {
    genprgShbang
    genprgSelfDestroy
    genprgFunctions \
        computeSha1 \
        setup_arch \
        setup_arch_SunOS \
        setup_arch_msysgit \
        die
    genprgRemoteCatReceiveImpl "$@"
}

genprgSelfDestroy() {
    cat <<\EOF
trap "rm -f '$0'" EXIT
EOF
}

genprgRemoteCatReceiveImpl() {
    cat <<EOF
objdir='$1/objects'
obj='$2'
opt_xbit='$3'

EOF

    cat <<\EOF
setup_arch

objsha1="${obj//\//}"

if ! test -d "${objdir}"; then
    die "Missing silo dir '${objdir}' (run 'git-silo init' at remote to create it)."
fi
cd "${objdir}"
subdir="$(dirname "${obj}")"
if ! [ -e "${subdir}" ]; then
    mkdir "${subdir}"
    if test -g "."; then
        chmod g+ws "${subdir}"
    fi
fi

tmp="${obj}-tmp"
rm -f "${tmp}"
cat >"${tmp}"
test ${opt_xbit} && chmod a+x "${tmp}"
chmod a-w "${tmp}"
if [ $(computeSha1 <"${tmp}") != "${objsha1}" ]; then
    rm -f "${tmp}"
    die "Checksum mismatch."
fi
chmod g+r "${tmp}"
mv "${tmp}" "${obj}"
EOF
}

lsRemoteObjects() {
    local host="$1"
    local objdir="$2/objects"
    exec_ssh "${host}" bash -s <<EOFPRG |
set -o errexit
if test -e '${objdir}'; then
    cd '${objdir}'
    find . -type f
fi
EOFPRG
    sed -e 's@^\./@@' ||
        die "Failed to list silo objects at '$1' in '$2'."
}

lsRemoteObjectsWithPacked() {
    local host="$1"
    local objdir="$2/objects"
    local packdir="$2/packs"
    exec_ssh "${host}" bash -s <<EOFPRG ||
set -o errexit

if test -e '${objdir}'; then
    cd '${objdir}'
    find . -type f | cut -b 3-
fi

if test -e '${packdir}'; then
    cd '${packdir}'
    find . -type f -name '*.lst' -exec cat '{}' ';'
fi
EOFPRG
    die "Failed to list silo objects at '$1' in '$2'."
}

catPackLsts() {
    local packdir="$1/packs"
    test -e "${packdir}" || return 0
    (
        cd "${packdir}"
        find . -type f -name '*.lst' -exec cat '{}' ';'
    )
}

transport_sshcat_prefetch() {
    local url="$1"
    local url_host url_dir
    read url_host url_dir <<< "$(parseUrl "$url")"
    local prgpath
    # Write url to program to protect it from msysgit path mangling.  Pass
    # prgpath together with bash in a single string to protect prgpath from
    # mangling.
    prgpath=$(genprgRemoteAutoUnpackInDir "${url_dir}" |
        exec_ssh "${url_host}" bash -c \
            "'p=\$(mktemp /tmp/git-silo-prefetch.XXXXXX); cat >\$p; echo \$p'")
    exec_ssh "${url_host}" "bash '${prgpath}'" ||
        die "Failed to autounpack at remote."
}

genprgRemoteAutoUnpackInDir() {
    genprgShbang
    genprgSelfDestroy
    genprgFunctions \
        die \
        setup_arch \
        setup_arch_SunOS \
        setup_arch_msysgit \
        findBin7z \
        forEachGroup \
        getSiloDir \
        getSiloObjectDir \
        getSiloPackDir \
        isSharedDir \
        selectMissingSha1s \
        lookupPacksForObjects \
        lsPacksWithObjects \
        lsSlashedPacks \
        tryAutoUnpackInDir \
        mkdirWithParentsPermissions \
        mktempSiloDir \
        nCPU \
        packtool_7z_extract \
        packtool_7z_ls \
        sha1AsObjectPath \
        slashedOnce \
        unpackObjects
    genprgRemoteAutoUnpackInDirImpl "$@"
}

genprgRemoteAutoUnpackInDirImpl() {
    cat <<EOF
setup_arch
tryAutoUnpackInDir '$1'
EOF
}

# transport_sshcat

exec_ssh() {
    local defaultargs=
    local ssh=${GIT_SSH:-ssh}
    case "$ssh" in
    *plink*)
        defaultargs=-batch
        ;;
    esac
    "$ssh" $defaultargs "$@"
}

transport_localcp_fetch() {
    local objdir remoteObjdir dir objPathMap src dest tmp
    remoteObjdir="$1/objects"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    objdir=$(getSiloObjectDir)
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        src="${remoteObjdir}/${p}"
        dest="${objdir}/${p}"
        if ! [ -e "${src}" ]; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"

        if test $opt_dry_run; then
           continue
        fi

        dir="$(dirname "$p")"
        mkdirWithParentsPermissions "$objdir/$dir"

        # Try to link, but only if source has correct permissions.
        if ! test -w "${src}"; then
            echo_debug "ln $src ..."
            if ln "${src}" "${dest}" >/dev/null 2>&1; then
                continue
            fi
        fi

        echo_debug "cp ${src} ..."
        tmp="${dest}-tmp"
        rm -f "${tmp}"
        cp "${src}" "${tmp}" ||
            die "Failed to copy '$p'."
        chmod a-w "${tmp}"
        mv "${tmp}" "${dest}"
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

transport_localcp_push_prepush() {
    local url="$1"
    local silourl="$2"
    local packedAtRemote="$(catPackLsts "${silourl}")"
    local objdir="${silourl}/objects"
    local alternates="$(cd "${url}" && resolveAlternates)"
    while read -r sha1; do
        [ -z "${sha1}" ] && continue
        p=$(sha1AsObjectPath "${sha1}")
        [ -f "${objdir}/${p}" ] && continue
        findLineIn "${p}" "${packedAtRemote}" && continue
        tryPrepushLinkToAlternate "${sha1}" && continue
        printf 'MISSING %s\n' "${sha1}"
    done
}

# Uses `alternates` and `objdir` from caller.
tryPrepushLinkToAlternate() {
    local sha1="$1"
    local p="$(sha1AsObjectPath "${sha1}")"
    local src dir
    while IFS= read -r alt; do
        [ -z "${alt}" ] && continue
        src="${alt}/${p}"
        [ -f "${src}" ] || continue
        dir=$(dirname ${p})
        mkdirWithParentsPermissions "${objdir}/${dir}"
        ln "${src}" "${objdir}/${p}" || continue
        printf 'LINKED %s\n' "${sha1}"
        return 0
    done <<<"${alternates}"
    return 1
}

transport_localcp_push() {
    local objdir remoteObjdir objPathMap
    remoteObjdir="$1/objects"
    if ! [ -d "${remoteObjdir}" ]; then
        die "Missing silo dir '${remoteObjdir}' (run 'git-silo init' at remote to create it)."
    fi
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    objdir=$(getSiloObjectDir)
    while read what p; do
        [ -z "$p" ] && continue
        p=$(sha1AsObjectPath "$p")
        if [ "${what}" = "LINKED" ]; then
            printSyncInfo "Linked to alternate at remote" "$p" "$objPathMap" >&2
            continue
        fi
        if ! [ -f "$objdir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            echo_debug "Would have run: cp" "$objdir/$p" "${remoteObjdir}/$p"
        else
            dir=$(dirname $p)
            mkdirWithParentsPermissions "${remoteObjdir}/$dir"

            src="${objdir}/${p}"
            dest="${remoteObjdir}/${p}"

            # Try to change to read-only to contain Windows madness that
            # requires to change files to writable when deleting a hardlink.
            [ -w "${src}" ] && chmod a-w "${src}" || true

            rm -f "${dest}-tmp"

            if ( isGroupReadable "${src}" || chmod g+r "${src}" 2>/dev/null ) &&
                ln "${src}" "${dest}" >/dev/null 2>&1; then
                echo_debug 'linked'
                continue
            fi

            echo_debug "cp ..."
            cp "${src}" "${dest}-tmp"
            chmod a-w "${dest}-tmp"
            chmod g+r "${dest}-tmp"
            mv "${dest}-tmp" "${dest}"
        fi
    done
}

isGroupReadable() {
    ls -l "$1" | grep -q '^....r'
}

transport_localcp_prefetch() {
    tryAutoUnpackInDir "${url}"
}

tryAutoUnpackInDir() {
    local dir="$1"
    # Always consume input (cat >/dev/null) to avoid broken pipe.
    [ -d "${dir}" ] || {
        cat >/dev/null
        return 0
    }
    [ "$(cd "${dir}" && git config silo.autounpack)" = "true" ] || {
        cat >/dev/null
        return 0
    }

    packtool=7z
    packext=7z

    (
        cd "${dir}"
        if [ -d "$(getSiloPackDir)" ] && findBin7z; then
            echo 'auto unpacking if necessary...'
            selectMissingSha1s |
            lookupPacksForObjects |
            sort -k 1 |
            forEachGroup unpackObjects
        else
            selectMissingSha1s |
            while read s; do
                [ -z "${s}" ] && continue
                printf 'Warning: cannot unpack %s.\n' "${s}"
            done
        fi
    )
}

selectMissingSha1Paths() {
    local objdir="$(getSiloObjectDir)"
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue
        [ -f "${objdir}/$(sha1AsObjectPath ${sha1})" ] && continue
        printf '%s %s\n' "${sha1}" "${path}"
    done
}

selectMissingSha1s() {
    local objdir="$(getSiloObjectDir)"
    while read p; do
        [ "${p}" = "" ] && continue
        [ -f "${objdir}/$(sha1AsObjectPath ${p})" ] && continue
        printf '%s\n' "${p}"
    done
}

selectMissingSha1sWithPacked() {
    local objdir="$(getSiloObjectDir)"
    local packed="$(catPackLsts "$(getSiloDir)" | sed -e 's@/@@')"
    while read p; do
        [ "${p}" = "" ] && continue
        [ -f "${objdir}/$(sha1AsObjectPath ${p})" ] && continue
        findLineIn "${p}" "${packed}" && continue
        printf '%s\n' "${p}"
    done
}

printSyncInfo() {
    local msg=$1
    local p=$2
    local objPathMap=$3
    local sha1=$(cut -b 1-2,4-41 <<<"$p")
    grep $sha1 <<<"$objPathMap" |
        sed -e "s/^/$msg /"
}

mkdirWithParentsPermissions() {
    local d=$1
    local parentd=$(dirname "$d")
    if [ -d "$d" ]; then
        return 0
    fi
    mkdir -p "$d"
    if isSharedDir "$parentd"; then
        chmod g+ws "$d"
    fi
}

isSharedDir() {
    test -g "$1"
}

# Lines must not contain special basic regex characters.
# SHA1s are ok.  Relative silo object paths 'xx/xxx...' are also ok.
findLineIn() {
    grep -q "^$1\$" <<< "$2"
}

getTransport() {
    if [ "${1/://}" = "$1" ] || isWindowsAbsPath "$1"; then
        echo localcp
    else
        cfg_sshtransport
    fi
}

cfg_sshtransport() {
    local o
    o=$(git config silo.sshtransport) || o=sshcat
    case ${o} in
    sshcat)
        echo ${o}
        ;;
    *)
        printf "Warning: invalid option silo.sshtransport = '%s'; using 'sshcat'.\n" "${o}" >&2
        echo sshcat
    esac
}

isWindowsAbsPath() {
    grep -q '^[a-zA-Z]:/' <<< "$1"
}

parseUrl() {
    sed -e 's/:/ /' <<< "$1"
}

uniqSha1s() {
    cut -b 1-40 |
    sort -u
}

# Add slashes every second prefix hexdigit if followed by more hexdigits.
slashedPrefix() {
    local prev=
    local cur="$1"
    while [ "${prev}" != "${cur}" ]; do
        prev="${cur}"
        # Transform '^aaa -> ^aa/a' and '.../aaa' -> '.../aa/a'.
        cur=$(sed -E -e 's@(^|/)([0-9a-f]{2})([0-9a-f])@\1\2/\3@g' <<<"${cur}")
    done
    printf '%s' "${cur}"
}

# Add slash after starting two hexdigits if followed by another hexdigit.
slashedOnce() {
    sed -E -e 's@^([0-9a-f]{2})([0-9a-f])@\1/\2@'
}

sha1sAsObjectPaths() {
    slashedOnce
}

sha1AsObjectPath() {
    local sha1="$1"
    echo ${sha1:0:2}/${sha1:2}
}

# hasSiloAttrLabel <label> <path>
#
# return true if silo attribute of <path> contains <label>.
hasSiloAttrLabel() {
    local label=$1
    local path=$2
    local attr
    attr=$(getAttrValue "silo" "${path}")
    case ",${attr}," in
        *,${label},*)
            return 0
            ;;
    esac
    false
}

filterSiloAttr() {
    local attr
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue
        attr=$(getAttrValue "silo" "${path}")
        if ! passFilter "$attr" "$@"; then
            test $opt_verbose && printf "    skipping %s\n" "${path}" >&2
            continue
        fi
        printf '%s %s\n' "${sha1}" "${path}"
    done
}

passFilter() {
    local attr=$1
    shift
    for f in "$@"; do
        read -r cmd label <<<"${f}"
        case ",${attr}," in
        *,${label},*)
            case "${cmd}" in
            +)
                return 0
                ;;
            -)
                return 1
                ;;
            *)
                die "Invalid filter command in filter rule '${cmd} ${label}'."
            esac
            ;;
        esac
    done
    return 0
}

getRemoteUrl() {
    local url reurl
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if isRemoteName "${remote}"; then
        url=$(git config remote."${remote}".url) ||
            die "Failed to get URL of remote '${remote}'.  If you meant '${remote}' to be a path, separate it by a double dash: '-- ${remote} ...'."
    else
        url="${remote}"
    fi
    if grep -q '^ssh://' <<< "$url"; then
        url=$(sed -e 's@ssh://@@' -e 's@/@:/@' -e 's@//@/@' \
            -e 's@:/~@:~@' <<< "$url")
    elif grep -q '^[^:]*://' <<< "$url"; then
        die "Don't know how to use $url."
    fi
    printf '%s\n' "${url}"
}

getRemoteSiloUrl() {
    local url="$(getRemoteUrl)"
    reurl=$(resolveGitDir "$url") ||
        die "Failed to resolve git-dir for '$url'."
    printf '%s/silo\n' "$reurl"
}

isRemoteName() {
    grep -q '^[a-zA-Z0-9-]*$' <<<"$1"
}

resolveGitDir() {
    local url=$1
    local url_host url_dir
    case $(getTransport "$url") in
    localcp)
        url=$(cd "$url" && cd "$(git rev-parse --git-dir)" && pwd)
        ;;
    sshcat)
        read url_host url_dir <<< "$(parseUrl "$url")"
        url_dir=$(
            exec_ssh "$url_host" bash -s <<EOFPRG
set -o errexit
test -e '$url_dir'
cd '$url_dir'
cd "\$(git rev-parse --git-dir)"
pwd
EOFPRG
        ) || die "Failed 'ssh $url_host bash ...' to determine git-dir."
        url=$url_host:$url_dir
        ;;
    esac
    printf '%s' "$url"
}

cmd_gc() {
    validateNoStagedChanges
    test $opt_force || validateNoUnstagedChanges
    validateHaveSilo
    gcSiloObjects
    if test $opt_gitattributes; then
        gcAllGitattributes
    fi
}

gcSiloObjects() {
    local objdir current stored remove
    current=$(allCurrentSiloObjects)
    current=$(convertToObjectSubdirPaths <<< "$current")

    objdir=$(getSiloObjectDir)
    stored=$(lsDir "$objdir")

    remove=$(setminus "$stored" "$current")
    if test $opt_dry_run; then
        sed -e 's/^/Would remove /' <<<"${remove}"
        return 0
    fi
    while IFS= read -r p; do
        [ -n "${p}" ] || continue
        printf 'Removing %s\n' "${p}"
        rm -f "${objdir}/${p}"
    done <<<"${remove}"
    removeEmptyObjectDirs
}

removeEmptyObjectDirs() {
    find "$(getSiloObjectDir)" \
        -mindepth 1 -maxdepth 1 -type d -empty -exec rmdir '{}' ';' || true
}

cmd_purge() {
    validateHaveSilo

    local orphanSha1s objdir shouldRemoveObject sha1 path objpath
    local msg_remove msg_placeholder

    [[ $(cfg_ismasterstore) == "false" ]] ||
        die "purge requires silo.ismasterstore=false."

    test $opt_force || test $opt_dry_run ||
        die "purge requires either -f or --dry-run."

    (( ${#arg_pathspec[@]} )) ||
        die "purge requires a path."

    validateNoStagedChanges
    validateNoUnstagedChanges

    if test $opt_force; then
        msg_remove="Removing"
        msg_placeholder="Using placeholder"
    else
        msg_remove="Would remove"
        msg_placeholder="Would use placeholder"
    fi

    orphanSha1s="$(orphanSha1sWithoutPaths "${arg_pathspec[@]}")"
    objdir=$(getSiloObjectDir)

    # If silo.masterstore is set, verify that all objects are there.
    masterobjdir=
    if masterstore=$(git config silo.masterstore); then

        masterobjdir="$(
            cd "${masterstore}" && getSiloObjectDir
        )" && [ -d "${masterobjdir}" ] ||
            die "failed to resolve git silo at masterstore '${masterstore}'."

        if test ${opt_strict_masterstore}; then
            lsSiloTracked "${arg_pathspec[@]}" | (
                err=
                while read -r sha1 path; do
                    [ -z "${sha1}" ] && continue
                    p="$(sha1AsObjectPath "${sha1}")"
                    objpath="${objdir}/${p}"
                    if [ -f "${objpath}" ] && grep -q -F "${sha1}" <<<"${orphanSha1s}"; then
                        if ! [ -f "${masterobjdir}/${p}" ]; then
                            printf 'missing in masterstore %s %s\n' "${sha1}" "${path}"
                            err=t
                        fi
                    fi
                done
                if test ${err}; then
                    die "Refusing to purge, because some objects above are not in silo.masterstore '${masterstore}'."
                fi
            ) || exit 1
        fi
    fi

    lsSiloTracked "${arg_pathspec[@]}" |
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue

        p="$(sha1AsObjectPath "${sha1}")"
        objpath="${objdir}/${p}"
        if [ -f "${objpath}" ] && grep -q -F "${sha1}" <<<"${orphanSha1s}"; then
            if [ -n "${masterobjdir}" ] && ! [ -f "${masterobjdir}/${p}" ]; then
                printf 'Not in masterstore, keeping %s %s\n' "${sha1}" "${path}"
                continue
            fi
            shouldRemoveObject=t
            printf "%s %s %s\n" "${msg_remove}" "${sha1}" "${path}"
        elif ! isSha1PlaceholderFile "${path}"; then
            shouldRemoveObject=
            printf "%s %s %s\n" "${msg_placeholder}" "${sha1}" "${path}"
        else
            continue
        fi

        if ! test $opt_force; then
            continue
        fi

        rm -f "${path}"
        printf '%s\n' "${sha1}" >"${path}"
        git add -u "${path}"

        if ! test $shouldRemoveObject; then
            continue;
        fi

        rm -f "${objpath}"
    done

    removeEmptyObjectDirs
}

# Count how often a sha1 is used (1) by all files of HEAD and (2) when files
# are restricted to paths.  Join counts on sha1 and keep only sha1s that are
# present in both sets with same count.  These sha1s become orphans when the
# paths are removed.
orphanSha1sWithoutPaths() {
    (
        lsSiloTracked | sha1Counts &&
        lsSiloTracked "$@" | sha1Counts
    ) |
    joinCounts |
    sha1sWithEqualCounts
}

# Join counts from consecutive lines with equal sha1.
joinCounts() {
    local sha1 c prevc
    local prevsha1=

    sed -e 's/^ *//' |
    sort -s -k 2 |
    while read -r c sha1; do
        [ "${sha1}" = "" ] && continue
        if [ "${sha1}" = "${prevsha1}" ]; then
            printf "%s %s %s\n" "${sha1}" "${prevc}" "${c}"
        fi
        prevsha1="${sha1}"
        prevc="${c}"
    done
}

sha1sWithEqualCounts() {
    local sha1 c1 c2
    while read -r sha1 c1 c2; do
        [ "${sha1}" = "" ] && continue
        (( $c1 != $c2 )) && continue
        printf '%s\n' "${sha1}"
    done
}

sha1Counts() {
    cut -b 1-40 |
    sort |
    uniq -c
}

lsDir() {
    cd "$1" && find . -type f | sed -e 's@^\./@@'
}

lsSiloObjectsInDirWithSize() {
    lsDirWithSize "$1" |
    egrep ' [0-9a-f]{2}/[0-9a-f]{38}$' || true
}

# Use find to determine correct file size on msysgit.  Use sed to normalize
# output of 'find -ls' (compress whitespace, remove everything before
# permission field).  Use sed to remove leading './' See also note at
# fileSize().
lsDirWithSize() {
    (
        cd "$1" &&
        find . -type f -ls |
        sed -e 's/  */ /g' -e 's/^[^-]*-/-/' |
        cut -d ' ' -f 5,9 |
        sed -e 's@\./@@'
    )
}

allCurrentSiloObjects() {
    if test $opt_n; then
        while read ref; do
            [ "$ref" = "" ] && continue
            siloObjectsWithRevListArgs -n $opt_n $ref
        done <<< "$(allLocalRefs)" |
        sort -u
    else
        siloObjectsWithRevListArgs --all
    fi
}

# Parse output of 'cat-file --batch' by keeping every line that looks like a
# sha1.  This should be a robust, conservative listing, even if some git
# objects have the same size as sha1 placeholders.
siloObjectsWithRevListArgs() {
    git rev-list --objects "$@" |
    cut -d ' ' -f 1 |
    git cat-file --batch-check |
    ( grep 'blob 41$' || true ) |  # true avoids pipefail if no match.
    cut -d ' ' -f 1 |
    sort -u |
    git cat-file --batch |
    ( egrep '^[0-9a-f]{40}$' || true )
}

allLocalRefs() {
    git rev-parse HEAD
    git show-ref --heads $(test $opt_tags && echo --tags) -s
}

convertToObjectSubdirPaths() {
    sed -e 's@^\(.\{2\}\)@\1/@'
}

# A duplicate of this function is tested in t8904.
setminus() {
    { sed <<<"$1" -e 's/^/1 /'; sed <<<"$2" -e 's/^/2 /'; } |
    sort -k 2 --stable | (
        hold=
        while read -r which x; do
            case ${which} in
            1)
                if [ -n "${hold}" ]; then
                    printf '%s\n' "${hold}"
                fi
                hold=${x}
                ;;
            2)
                if [ -n "${hold}" ] && [ "${hold}" != "${x}" ]; then
                    printf '%s\n' "${hold}"
                fi
                hold=
                ;;
            esac
        done
        if [ -n "${hold}" ]; then
            printf '%s\n' "${hold}"
        fi
    )
}

gcAllGitattributes() {
    while IFS= read -r p; do
        [ "$p" = "" ] && continue
        gcGitattributes "${p}"
    done <<< "$(lsGitattributes)"
    test $opt_dry_run && return 0
    git commit -m "git-silo gc gitattributes" &&
        echo "Consider amending the commit to explain the reason."
    true
}

gcGitattributes() {
    local attr tmpfile dir reEntry
    attr="$1"
    dir="$(dirname "${attr}")"
    tmpfile="${attr}-tmp$$"
    reEntry='^/.*filter=silo -text$'
    grep -v "${reEntry}" "${attr}" >"${tmpfile}" || true
    while read -r path rest; do
        if [ -f "$dir/$path" ]; then
            printf '%s filter=silo -text\n' "$path" >>"${tmpfile}"
        fi
    done <<< "$(grep "$reEntry" "${attr}")"
    if test $opt_dry_run; then
        diff "${attr}" "${tmpfile}" >/dev/null || echo "Would clean up '$attr'."
        rm "${tmpfile}"
        return 0
    fi
    mv "${tmpfile}" "${attr}"
    git add "${attr}"
}

lsGitattributes() {
    git ls-files | egrep '^.gitattributes|/.gitattributes'
    true
}

cmd_fsck() {
    local objdir expected_sha1 actual_sha1
    validateHaveSilo
    objdir="$(getSiloObjectDir)"
    local haveErr=
    while read -r p; do
        [ "$p" = "" ] && continue
        expected_sha1=${p/\//}
        actual_sha1=$(computeSha1 <"$objdir/$p") ||
            die "Failed to compute sha1 for '$p'."
        if [ $expected_sha1 != $actual_sha1 ]; then
            printf 'Error: %s corrupted, has wrong sha1 %s\n' \
                "$p" "$actual_sha1"
            haveErr=t
        fi
    done <<<"$(lsSiloObjectsInDir "$objdir")"
    test $haveErr && die "There have been errors (see above)."
    echo ok
}

cmd_pack() {
    packtool=7z
    packext=7z
    requireBin7z

    validateHaveSilo
    mkSiloPackDir

    lsObjectsWithPackPrefix |
    sort -k 1 |
    forEachGroup updatePack

    prunePackedObjects
}

cmd_unpack() {
    packtool=7z
    packext=7z
    requireBin7z

    validateHaveSilo

    [ -d "$(getSiloPackDir)" ] || return 0

    lsObjectsSelectedForUnpack |
    dropSha1sOfLooseObjects |
    lookupPacksForObjects |
    sort -k 1 |
    forEachGroup unpackObjects

    test $opt_keep_packs || prunePacks
}

mkSiloPackDir() {
    local packdir="$(getSiloPackDir)"
    mkdirWithParentsPermissions "${packdir}"
}

lsObjectsSelectedForUnpack() {
    if test $opt_all; then
        lsPackedObjects
    else
        lsSiloTracked "${arg_pathspec[@]}" |
        cut -d ' ' -f 1
    fi
}

dropSha1sOfLooseObjects() {
    local objectdir="$(getSiloObjectDir)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        [ -e "${objectdir}/$(sha1AsObjectPath ${sha1})" ] && continue
        printf '%s\n' "${sha1}"
    done
}

lookupPacksForObjects() {
    local sha1
    local packidx="$(lsPacksWithObjects)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        grep "${sha1}\$" <<<"${packidx}" ||
            printf 'nopack %s\n' "${sha1}"
    done
}

unpackObjects() {
    local pack="$1"
    local sha1s="$2"
    local objectdir="$(getSiloObjectDir)"
    local packdir="$(getSiloPackDir)"
    local tmpdir

    [ "$pack" == "nopack" ] && return 0

    tmpdir="$(mktempSiloDir)"
    # Clean up on exit.  Handlers for SIG* need to be set for Linux.  On Mac,
    # EXIT alone is sufficient.  Interestingly, setting 'true' as a handler for
    # SIG* also works.  The EXIT handler seems to be executed only if the
    # signal is handled somehow, how in detail does not matter.
    trap "rm -rf '${tmpdir}'" EXIT
    trap "rm -rf '${tmpdir}'; exit 1" SIGHUP SIGINT SIGTERM

    printf '%s' "${sha1s}" | slashedOnce | (
        cd "${tmpdir}" &&
        packtool_${packtool}_extract "${packdir}/${pack}"
    ) || die "Failed to extract object files from archive."

    for sha1 in ${sha1s}; do
        subdir="${sha1:0:2}"
        objfile="${sha1:2}"
        mkdirWithParentsPermissions "${objectdir}/${subdir}"
        chmod a-w "${tmpdir}/${subdir}/${objfile}"
        mv "${tmpdir}/${subdir}/${objfile}" "${objectdir}/${subdir}/${objfile}"
    done

    rm -rf "${tmpdir}"
}

prunePackedObjects() {
    [ "${opt_keep}" == "all" ] && return 0

    local objectdir="$(getSiloObjectDir)"
    local tipobjs packedobjs sha1
    tipobjs=$(lsSiloTracked | cut -d ' ' -f 1)
    packedobjs=$(lsPackedObjects)
    lsSiloObjectsInDir "${objectdir}" |
    while IFS= read -r path; do
        [ -z "${path}" ] && continue
        sha1="${path/\//}"

        # Always skip unpacked.
        grep -q -F "${sha1}" <<<"${packedobjs}" || continue

        # Skip tip objects if requested.
        if [ "${opt_keep}" == "tip" ]; then
            grep -q -F "${sha1}" <<<"${tipobjs}" && continue
        fi

        echo "Removing ${path}"
        rm -f "${objectdir}/${path}"
    done
    removeEmptyObjectDirs
}

prunePacks() {
    lsPacksWithObjects |
    sort -k 1 |
    forEachGroup prunePack
}

prunePack() {
    local pack="$1"
    local objs="$2"

    haveAllLooseObjects "${objs}" || return 0

    local packdir="$(getSiloPackDir)"
    rm -f "${packdir}/${pack}.lst"
    rm -f "${packdir}/${pack}"
}

haveAllLooseObjects() {
    local objectdir="$(getSiloObjectDir)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        [ -e "${objectdir}/$(sha1AsObjectPath ${sha1})" ] || return 1
    done <<<"${objs}"
}

# Determine pack prefix for loose objects.  Output: <prefix><SPACE><object>.
# Example:
#
#    _ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#    b_ bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
#    nopack cccccccccccccccccccccccccccccccccccccccc
#
# 'nopack' indicates that object is too large to pack.
# 'packed' indicates that object is contained in existing pack.
# 'tip' indicates that object is used by HEAD.
lsObjectsWithPackPrefix() {
    local packedobjs tipobjs prefixes
    local threshold=$(cfg_packSizeLimit)
    packedobjs=$(lsPackedObjects)
    tipobjs=$(lsSiloTracked | cut -d ' ' -f 1)
    for i in {0..39}; do
        prefixes[${i}]=''
    done
    local cumsums
    lsSiloObjectsInDirWithSize "$(getSiloObjectDir)" |
    sed -e 's@/@@' |
    sort -k 2 |
    while read -r size name; do
        [ -z "${name}" ] && continue
        # Debugging code:
        # printf >&2 "%s " "${prefixes[@]}"
        # echo >&2
        # printf >&2 "%d " "${cumsums[@]}"
        # echo >&2

        if grep -q -F "${name}" <<<"${packedobjs}"; then
            echo packed ${name}
            continue
        fi

        if ! test $opt_all &&
            grep -q -F "${name}" <<<"${tipobjs}"; then
            echo tip ${name}
            continue
        fi

        if (( ${threshold} > 0 )) && (( ${size} > ${threshold} )); then
            echo nopack ${name}
            continue
        fi

        for level in {0..39}; do
            curprefix="${name:0:${level}}_"
            if [ "${prefixes[${level}]}" != "${curprefix}" ]; then
                prefixes[${level}]=${curprefix}
                cumsums[${level}]=0
                oldpack=$(findPackWithPrefix "${curprefix}")
                if [ -n "${oldpack}" ]; then
                    cumsums[${level}]=$(fileSize "${oldpack}")
                fi
            fi
            newsize=$(( ${cumsums[${level}]} + ${size} ))
            if (( ${threshold} == 0)) || (( ${newsize} < ${threshold} )); then
                echo ${curprefix} ${name}
                cumsums[${level}]=${newsize}
                continue 2
            fi
        done
        echo nopack ${name}
    done
}

forEachGroup() {
    local prefix=
    local group
    while read -r p o; do
        [ -z "${p}" ] && continue
        if [ "${p}" != "${prefix}" ]; then
            if [ -n "${prefix}" ]; then
                "$@" "${prefix}" "${group}" </dev/null
            fi
            prefix="${p}"
            group=
        fi
        group="${group}${o}
"
    done
    if [ -n "${prefix}" ]; then
        "$@" "${prefix}" "${group}" </dev/null
    fi
}

updatePack() {
    local objectdir="$(getSiloObjectDir)"
    local packdir="$(getSiloPackDir)"
    local prefix="$1"
    local objs="$2"

    # Skip objects that are too large to be packed.
    [ "${prefix}" == "nopack" ] && return 0

    # Skip objects that are already packed.
    [ "${prefix}" == "packed" ] && return 0

    # Skip objects that are used by tip.
    [ "${prefix}" == "tip" ] && return 0

    # Compute preliminary id based on objects in pack.
    oldpack=$(findPackWithPrefix "${prefix}")
    packobjsid="$(
        (
            if [ -n "${oldpack}" ]; then
                packtool_${packtool}_ls "${oldpack}"
            fi &&
            printf '%s' "${objs}"
        ) |
        sed -e 's@/@@' |
        sort -u |
        computeSha1
        )"

    # Prepare tmp pack.
    pathprefix="${packdir}/$(slashedPrefix "${prefix}")"
    tmppackfile="${pathprefix}${packobjsid}.${packext}-tmp"
    mkdirWithParentsPermissions "$(dirname "${tmppackfile}")"
    rm -f "${tmppackfile}"

    # Add objects
    printf '%s' "${objs}" | slashedOnce | (
        cd "${objectdir}" &&
        packtool_${packtool}_add "${oldpack}" "${tmppackfile}"
    ) || die "Failed to add object files to archive."
    chmod a-w "${tmppackfile}"

    # Double check that pack contains the expected objects.
    verifyPackfileObjsId "${tmppackfile}"

    # Compute final pack id based on its sha1, create listing, move in place,
    # and clean up.
    packcontentid=$(computeSha1 <"${tmppackfile}")
    packfile="${pathprefix}${packcontentid}.${packext}"
    lstfile="${packfile}.lst"
    tmplstfile="${lstfile}-tmp"
    packtool_${packtool}_ls "${tmppackfile}" >"${tmplstfile}"
    mv "${tmppackfile}" "${packfile}"
    mv "${tmplstfile}" "${lstfile}"
    if [ -n "${oldpack}" ]; then
        rm -f "${oldpack}"
        rm -f "${oldpack}.lst"
    fi
}

findBin7z() {
    local try="7zr 7z"
    for b in $try; do
        if $b 2>&1 | grep -q "7-Zip"; then
            bin_7z=$b
            return 0
        fi
    done
    printf "Missing 7z binary (tried %s)." "${try}"
    return 1
}

requireBin7z() {
    findBin7z ||
    die "Missing 7z.  If using a package manager (Linux or Mac), install the package 'p7zip'; or install 7-Zip from http://www.7-zip.org and add it to PATH."
}

packtool_7z_add() {
    local src="$1"
    local dest="$2"

    # Clean up if interrupted.
    trap "rm -f '${dest}'; exit 1" SIGHUP SIGINT SIGTERM

    if [ -n "${src}" ]; then
        cp "${src}" "${dest}"
        chmod u+w "${dest}"
    fi
    # Use LZMA2 to support multi-threaded compression.
    # Disable solid mode (-ms=off) to allow quickly accessing individual files.
    xargs ${bin_7z} a -t7z -m0=LZMA2 -ms=off "${dest}"

    trap - SIGHUP SIGINT SIGTERM
}

packtool_7z_extract() {
    local pack="$1"
    local parallel=
    local ncpu
    ncpu="$(nCPU)"
    if (( ${ncpu} > 1 )); then
        echo "Using up to ${ncpu} processes for unpacking."
        # Use separate process for each object (-n 1) for parallel execution.
        parallel="-P ${ncpu} -n 1"
    fi
    xargs ${parallel} ${bin_7z} x "${pack}"
}

packtool_7z_ls() {
    # Select rows that contain file listing (separated by lines that contain
    # '------').  Drop listing separators.  isolate file names by removing
    # start of line up to space (assuming file names w/o spaces).
    #
    # More than 4 dashes must be used for compatibiliy with 7zr 9.04, since it
    # used 4 dashes to separate the header from the file info part.  The output
    # of '7zr l' is structured as follows:
    #
    #     <header>
    #     ---- (in version 9.04)
    #     --   (in version 9.20)
    #     <file-info>
    #
    #        Date      Time    Attr         Size   Compressed  Name
    #     ------------------- ----- ------------ ------------  ------------------------
    #     <listing>
    #     ------------------- ----- ------------ ------------  ------------------------
    #                        <totals>
    #
    ${bin_7z} l "$1" |
    sed -n -e '/------/,/------/p' |
    sed -e '1d' -e '$d' |
    sed -e 's/^.* //'
}

# Determine number of CPUs.
nCPU() {
    local n=
    case $(uname) in
    Linux*)
        n="$(grep -c ^processor /proc/cpuinfo || true)"
        ;;
    Darwin*)
        n="$(sysctl hw.ncpu | cut -d ' ' -f 2 || true)"
        ;;
    SunOS*)
        n="$(kstat -m cpu_info | grep -w core_id | uniq | wc -l | sed -e 's/^ *//' || true)"
        ;;
    esac
    if ! grep -q "^[1-9][0-9]*\$" <<<"${n}"; then
        n=1
    fi
    printf '%d' "${n}"
}

lsPackedObjects() {
    lsPacksWithObjects |
    cut -d ' ' -f 2
}

lsPacksWithObjects() {
    packdir="$(getSiloPackDir)"
    lsSlashedPacks |
    while IFS= read -r pack; do
        [ -z "${pack}" ] && continue
        packtool_${packtool}_ls "${packdir}/${pack}" |
        sed -e 's@/@@' -e "s@^@${pack} @"
    done
}

lsSlashedPacks() {
    (
        cd "$(getSiloPackDir)" &&
        find . -type f -name "*_*.${packext}" |
        cut -b 3-
    )
}

findPackWithPrefix() {
    local prefix="$(slashedPrefix "$1")"
    (
        set +o noglob &&
        shopt -s nullglob &&
        printf '%s' "$(getSiloPackDir)"/${prefix}*.${packext}
    )
}

verifyPackfileObjsId() {
    local packfile="$1"
    local packobjsid
    packobjsid="$(
        packtool_${packtool}_ls "$packfile" |
        sed -e 's@/@@' |
        sort |
        computeSha1
        )"
    packid="$(packIdOfFile "${packfile}")"
    if [ "${packid}" != "${packobjsid}" ]; then
        die "Id from object list ('${packobjsid}') does not match packfile name '$(basename "${packfile}")'."
    fi
}

packIdOfFile() {
    local packfile="$1"
    local packid="${packfile##*_}"
    packid="${packid%%.*}"
    printf '%s' "${packid}"
}

lsSiloObjectsInDir() {
    lsDir "$1" |
    egrep '^[0-9a-f]{2}/[0-9a-f]{38}$' || true
}

cmd_dedup() {
    for r in "${arg_repos[@]}"; do
        validateHaveSiloAt "$r"
    done

    local prev_key=invalid
    local prev_dir
    local src dest tmp
    lsAllDedupCandidates |
    while read -r key dir; do
        if [ $key != $prev_key ]; then
            prev_key=$key
            prev_dir=$dir
            continue
        fi
        src=$prev_dir/$key
        dest=$dir/$key
        # Skip if files already use same inode.
        if [ "$(inodeNumber "${src}")" = "$(inodeNumber "${dest}")" ]; then
            continue
        fi
        if ( [ -x "${src}" ] && ! [ -x "${dest}" ] ) ||
            ( ! [ -x "${src}" ] && [ -x "${dest}" ] ) ; then
            printf >&2 "Warning: skipping link '%s' from '%s' to '%s', because x-bits differ.\n" \
                "$key" "$prev_dir" "$dir" >&2
            continue
        fi
        tmp=$dest-$$
        ln "$src" "$tmp" &&
        mv -f "$tmp" "$dest" || {
            printf "Warning: Failed to link '%s' from '%s' to '%s'.\n" \
                "$key" "$prev_dir" "$dir" >&2
        }
    done
}

inodeNumber() {
    ls -i "$1" | sed -e 's/^ *//' | cut -d ' ' -f 1
}

validateHaveSiloAt() {
    ( cd "$r" && validateHaveSilo ) ||
        die "Invalid silo '$r'."
}

lsAllDedupCandidates() {
    for r in "${arg_repos[@]}"; do
        lsDedupCandidates "$r"
    done |
    sort -k 1.1,1.41 -s
}

lsDedupCandidates() {
    local abspath
    abspath=$( cd "$1" && cd "$(getSiloObjectDir)" && pwd )
    # '|| true' avoids pipefail without match.
    (
    lsDir "$abspath" |
    ( egrep '^[0-9a-f]{2}/[0-9a-f]{38}$' || true )
    ) |
    while read -r line; do
        printf '%s %s\n' "$line" "$abspath"
    done
}

validateNoStagedChanges() {
    no_staged_changes || die "You have staged changes."
}

validateNoUnstagedChanges() {
    no_unstaged_changes || die "You have unstaged changes."
}

no_staged_changes() {
    git diff-index --quiet --cached HEAD
}

no_unstaged_changes() {
    git diff-files --quiet
}

dieMissingPath() {
    local what="$1"
    msg="Missing path.  '${what}' requires a path, either on the command line or in 'remote.<remote>.silo${what}'."
    if test "${arg_remote}"; then
        msg="$msg  The first argument '${arg_remote}' was interpreted as a remote.  If you meant to use remote 'origin' and ${what} a path, separate the argument by a double dash: '-- ${arg_remote}'."
    fi
    die "${msg}"
}

die() {
    echo >&2 "Error (silo): $1"
    exit 1
}

echo_debug() {
    if test $opt_debug; then
        echo >&2 "$@"
    fi
}

setup_arch() {
    case $(uname) in
    SunOS)
        setup_arch_SunOS
        ;;
    MINGW*)
        setup_arch_msysgit
        ;;
    esac
}

setup_arch_SunOS() {
    local required="gsort gsed gfind ggrep gegrep gxargs"
    local err=
    for c in ${required}; do
        if ! type >/dev/null 2>&1 $c; then
            printf >&2 "Missing '%s'.\n" "${c}"
            err=t
        fi
    done
    if test $err; then
        die "Missing GNU tools (see above)."
    fi

    sort() {
        gsort "$@"
    }
    sed() {
        gsed "$@"
    }
    find() {
        gfind "$@"
    }
    grep() {
        ggrep "$@"
    }
    egrep() {
        gegrep "$@"
    }
    xargs() {
        gxargs "$@"
    }
}

setup_arch_msysgit() {
    # cp fails for files >2GB.  Use cat instead.  Ignore x-bit; it is not
    # available on msysgit.
    cp() {
        cat "$1" >"$2"
    }
}

main "$@"
