#!/bin/bash

set -o nounset -o errexit -o pipefail -o noglob

opt_debug=

usage() {
    cat <<\EOF
git-silo init
git-silo add [--] [<file>...]
git-silo checkout [--copy] [--link] -- [<file>...]
git-silo status [<path>...]
git-silo push \
    [--dry-run] [-v|--verbose] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<remote>] [--] [<path>... | config remote.<remote>.silopush]
git-silo fetch \
    [--dry-run] [-v|--verbose] \
    [--include=<label>] [--exclude=<pattern>] [--all] \
    [<remote>] [--] [<path>... | config remote.<remote>.silofetch]
git-silo gc [--gitattributes] [-f|--force] [-n <number>] [--dry-run] [--no-tags]
git-silo purge [-f|--force] [--dry-run] [--] <path>...
git-silo pack [--all] [--keep-tip|--keep|--prune]
git-silo unpack [--keep-packs|--prune-packs] [--all] [--] [<path>...]
git-silo fsck
git-silo dedup <repo>...

  init              initialize silo.  Install clean and smudge git filters for
                    silo.  See also WILDCARD SETUP section.

  add               add untracked files for silo storage.  Creates hard link or
                    copy depending on value of 'silo.add'.  See CONFIGURATION
                    VARIABLES section.

  checkout          replace placeholders with full content.

    --copy          copy files instead of using hard link

    --link          replace checked-out copies with hard link

  status            print status of files stored in silo.

  push              push silo files for current HEAD.

    <remote>        git remote to push to (default: origin).

    <path>...       push will be limited to the given paths.  Default paths can
                    be configured with 'remote.<remote>.silopush'.  See PATHS
                    section.

  fetch             fetch silo files for current HEAD.

    <remote>        git remote to fetch from (default: origin).

    <path>...       fetch will be limited to the given paths.  Default paths
                    can be configured with 'remote.<remote>.silofetch'.  See
                    PATHS section.

  common options for push and fetch

    --dry-run       print what would be transferred.

    -v|--verbose    print more information, e.g. skipped files.

    --include=<pat> include files whose 'silo' attribute matches glob-style
                    pattern <pat>.  See TRANSFER FILTERS section.

    --exclude=<pat> exclude files whose 'silo' attribute matches glob-styl
                    pattern <pat>.  See TRANSFER FILTERS section.

    --all           include all files.  The default is to skip files whose
                    gitattributes 'silo' contains an entry 'local'.  See
                    TRANSFER FILTERS section.

  gc                remove silo files that are not directly referenced by
                    HEAD, tags or tips of branches.

    --gitattributes Also remove unused entries from '.gitattributes' and create
                    a commit if '.gitattributes' has been changed.

    -f|--force      run gc even with unstaged changes.  Note that gc might
                    modify and commit '.gitattributes'.

    -n <number>     keep only objects reachable from the latest <number>
                    commits at each local head, including tags.  Note that
                    objects that are only reachable from a remote tracking
                    branch will be removed.

    --no-tags       remove objects that are reachable only via a tag.

    --dry-run       print only what would be removed.

  purge             replace files by placeholders and remove objects from silo.
                    Since this is a very destructive operation (comparable to
                    rm -rf), 'silo.ismasterstore=false' and the '--force' flag
                    are both required to actually remove files.

    <path>...       the files to remove.

    -f|--force      required to actually remove files.

    --dry-run       print only what would be removed.

  fsck              verify silo storage.

  pack              pack loose silo objects into 7z archives.  Packed objects
                    are not automatically unpacked by operations such as
                    'checkout.'  Use 'unpack' to explicitly unpack objects.
                    The size of the archives can be controlled with
                    'silo.packSizeLimit' (see CONFIGURATION VARIABLES section).

    --all           pack all loose objects.  The default is to leave objects
                    unpacked that are used by HEAD.

    --keep-tip      keep loose objects for HEAD; prune other loose objects that
                    have been packed.  This is the default.

    --keep          keep all loose objects.

    --prune         prune all loose objects that have been packed.

  unpack            unpack loose objects that are used by HEAD.

    <path>...       limit unpacking to these files (default: all).

    --keep-packs    keep packs.  This is the default.

    --prune-packs   prune packs that have been completely unpacked.

    --all           unpack all packed objects no matter whether they are used
                    by HEAD or not.

  dedup             create hard links between repositories.  Repositories listed
                    later get linked to repositories listed earlier.
                    Deduplication might be incomplete if silo objects are owned
                    by different users and the OS restricts creation of hard
                    links.  See KNOWN ISSUES section.

# WILDCARD SETUP

Git can be told to use git silo for all files of a certain type (based on a glob
pattern).  This avoids the need to explicitly call 'git silo add' when a file is
added for the first time; a simple 'git add' will directly use git silo.  For
example, the following line in '.gitattributes' tells git to handle all mov
files using git silo:

    *.mov filter=silo -text

# PATHS

You must always either provide a path on the command line or via the config
variables 'remote.<remote>.silopush' or 'remote.<remote>.silofetch'.  Otherwise
git-silo will refuse to transfer files to protect you from accidentally starting
large transfers.  Use '-- .' to explicitly transfer everything.

# TRANSFER FILTERS

The gitattribute 'silo' can be used to limit file transfer.  Per default, files
that carry the label 'local' are not transferred.  This can be useful to handle
less important files.  They can be tracked locally, for example on a scratch
filesystem, without transferring them to a central, probably more reliable but
perhaps space-limited, storage.

'--include=<pattern>' and '--exclude=<pattern>' can be used to select files.
Each entry of the comma-separated list in gitattribute 'silo' is matched against
the glob-style <pattern>.  '--all' includes all files.  Filter order matters.
The first match decides.

For example, with the following line in '.gitattributes'

    /path silo=foo,bar,local

'path' will be

    excluded by default
    included for '--all'
    included for '--include=ba*'
    excluded for '--exclude=fo* --include=ba*'

# CONFIGURATION VARIABLES

silo.add (default 'link'): Controls behaviour of 'git silo add'.  If set to
'link', a hard link is stored and the original file's permissions set to
read-only.  If set to 'copy', a copy will be stored.  Always storing a copy
might be useful if you want to keep the file open in another application, like
Word, and use 'git-silo add' repeatedly.  When creating a hard link, the file
permissions are changed to read-only, which might confuse applications like
Word.

silo.contentSizeLimit (default '10M'): If the content for a file that is stored
in silo is smaller than the limit or the limit is 0, the content will be used
during normal git operations, such as 'git checkout', 'git reset', or 'git
archive'.  Otherwise, placeholders will be used.  The suffixes 'K', 'M', 'G' can
be used.  'git silo checkout' always uses the content and can will replace
placeholders in the working copy with the file content.  Note that placeholders
can be temporarily deactivated by using git's '-c' switch.  For example, the
following command will always create an archive with full content: 'git -c
silo.contentSizeLimit=0 archive HEAD >a.tar'

silo.packSizeLimit (default '50G'): The maximum size of a pack.  0 means no
limit.  The suffixes 'K', 'M', 'G' can be used.

silo.ismasterstore (default 'true'): Unless set to 'false', some destructive
operations, such as 'purge', are not permitted.

GIT_SSH (environment variable): If set, git-silo will use the specified program
instead of ssh.

silo.sshtransport (default 'sshcat'): Configures how to fetch and push files
via ssh.  With 'sshcat', one ssh connection is used per file.  'sshtar'
indicates that a single ssh connection is used together with tar, which doesn't
work on msysgit for files of 2GB or larger..

# KNOWN ISSUES

  - ssh performance on Windows might be poor (only 1 MB/s on local network).
    The reason is that openssh, which comes with msysgit, suffers from the
    problem explained in

        http://support.microsoft.com/kb/823764

    As a workaround, install PuTTY and tell git to use it (set GIT_SSH, use
    pageant).

  - silo.sshtransport 'sshtar' might fail on msysgit for files of 2GB or
    larger, because msysgit's tar does not work with large files.  Use the
    default silo.transport 'sshcat' instead.

  - git might fail with mmap out-of-memory on Windows.  Git on Windows is a
    32-bit executable, which fails for large files in some situations.  There is
    no known workaround.

  - If creation of hard links between different users is restricted, some
    operations might report warnings (like 'dedup') or copy data as a fall back
    ('fetch' from local filesystem).  Since Linux 3.6, the restrictions can be
    controlled with '/proc/sys/fs/protected_hardlinks' (see proc(5)).

EOF
}

main() {
    argparse "$@"
    validateGitVersion

    cmd_$arg_cmd
}

argparse() {
    arg_cmd=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if test "$arg_cmd"; then
                die "Wrong number of arguments"
            else
                validateCmd "$1"
                arg_cmd="$1"
                shift
                argparse_$arg_cmd "$@"
                return
            fi
            ;;
        esac
    done
    test "$arg_cmd" || die "Missing command."
}

argparse_init() {
    argparse_default "$@"
}

argparse_gc() {
    opt_force=
    opt_n=
    opt_dry_run=
    opt_tags=t
    opt_gitattributes=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --gitattributes)
            opt_gitattributes=t
            shift
            ;;
        --no-tags)
            opt_tags=
            shift
            ;;
        -n)
            shift
            [ $# -ge 1 ] || die "-n must be followed by number."
            opt_n=$1
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_fsck() {
    argparse_default "$@"
}

argparse_pack() {
    opt_keep=tip
    opt_all=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --keep)
            opt_keep=all
            shift
            ;;
        --keep-tip)
            opt_keep=tip
            shift
            ;;
        --prune)
            opt_keep=unpacked
            shift
            ;;
        --all)
            opt_all=t
            shift
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_unpack() {
    arg_pathspec=
    opt_keep_packs=t
    opt_all=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --keep-packs)
            opt_keep_packs=t
            shift
            ;;
        --prune-packs)
            opt_keep_packs=
            shift
            ;;
        --all)
            opt_all=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_dedup() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            break
            ;;
        esac
    done
    [ $# -ge 1 ] || die "Wrong number of arguments (expect at least two paths)."
    arg_repos=( "$@" )
}

argparse_purge() {
    opt_force=
    opt_dry_run=
    arg_pathspec=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            opt_force=t
            shift
            ;;
        --dry-run)
            opt_dry_run=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            break
            ;;
        esac
    done
}

argparse_default() {
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            die "Wrong number of arguments"
            ;;
        esac
    done
}

argparse_filter_smudge() {
    argparse_filter "$@"
}

argparse_filter_clean() {
    argparse_filter "$@"
}

argparse_filter() {
    (( $# == 1 )) || die "Missing <path>."
    arg_file="${1}"
    echo "Warning: using old-style git-silo filter, rerun 'git-silo init' to upgrade filters." >&2
}

argparse_add() {
    argparse_pathspec "$@"
}

argparse_checkout() {
    arg_pathspec=
    opt_copy=
    opt_link=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --copy)
            opt_copy=t
            shift
            ;;
        --link)
            opt_link=t
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_status() {
    argparse_pathspec "$@"
}

argparse_pathspec() {
    arg_pathspec=
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            return 0
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            arg_pathspec=( "$@" )
            return 0
            ;;
        esac
    done
}

argparse_fetch() {
    argparse_sync "$@"
}

argparse_push() {
    argparse_sync "$@"
}

argparse_sync() {
    local arg dummy
    opt_dry_run=
    opt_verbose=
    arg_pathspec=
    arg_remote=
    arg_filter=()
    while [ $# -ge 1 ]; do
        case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --dry-run)
            opt_dry_run=--dry-run
            shift
            ;;
        -v|--verbose)
            opt_verbose=t
            shift
            ;;
        --include=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "+ $arg" )
            ;;
        --exclude=*)
            IFS='=' read -r dummy arg <<<"$1"
            shift
            arg_filter+=( "- $arg" )
            ;;
        --all)
            arg_filter=( '+ *' )
            shift
            ;;
        --)
            shift
            [ $# -gt 0 ] && arg_pathspec=( "$@" )
            break
            ;;
        -*)
            die "Unknown option $1"
            ;;
        *)
            if ! test "$arg_remote"; then
                arg_remote="$1"
                shift
            else
                arg_pathspec=( "$@" )
                break
            fi
            ;;
        esac
    done
    (( ${#arg_filter[@]} )) || arg_filter=( '- local' )
}

validateGitVersion() {
    local version major minor
    version=$(git version)
    version=$(cut -d ' ' -f 3 <<<"$version")
    major=$(cut -d . -f 1 <<<"$version")
    minor=$(cut -d . -f 2 <<<"$version")
    [ $major -ge 1 ] && [ $minor -ge 8 ] ||
        die "git version too low (require at least version 1.8)."
}

validateCmd() {
    case "$1" in
    filter_smudge|filter_clean|add|status|push|fetch|init|checkout|gc|dedup|fsck|pack|unpack|purge)
        return 0
        ;;
    *)
        die "Invalid command '$1'."
        ;;
    esac
}

cmd_init() {
    local gitdir siloprg
    gitdir=$(git rev-parse --git-dir)
    echo "Initializing silo in '$gitdir'."
    mkdir -p "$gitdir/silo/objects"
    if isSharedDir "$gitdir/objects"; then
        echo "Using shared permissions."
        find "$gitdir/silo" -type d -print0 | xargs -0 chmod g+ws || {
            echo >&2 "Warning: shared permissions might be incompletely initialized (see above)."
        }
    fi
    if ! isBareRepo; then
        # git-silo uses hard link operations, which modify ctime.  Tell git to
        git config core.trustctime false
        configFilters
    fi
}

configFilters() {
    local silobindir
    silobindir=$(getSiloBinDir)
    mkdir -p "${silobindir}"
    genprgFilterClean >"${silobindir}/clean"
    chmod a+x "${silobindir}/clean"
    genprgFilterSmudge >"${silobindir}/smudge"
    chmod a+x "${silobindir}/smudge"
    # The leading space is necessary to avoid msys path mangling.
    git config filter.silo.clean ' "$(git rev-parse --git-dir)/silo/bin/clean" %f'
    git config filter.silo.smudge ' "$(git rev-parse --git-dir)/silo/bin/smudge" %f'
}

isBareRepo() {
    [ $(git rev-parse --is-bare-repository) = "true" ]
}

cmd_filter_clean() {
    validateHaveSilo
    if isSha1PlaceholderFile "$arg_file"; then
        tr -d '\r'
    else
        computeSha1AndStoreContentInSilo
    fi
}

genprgFilterClean() {
    genprgShbang
    genprgMainClean
    genprgFunctions \
        cmd_filter_clean \
        validateHaveSilo \
        getSiloObjectDir \
        getSiloDir \
        isSha1PlaceholderFile \
        fileSize \
        computeSha1AndStoreContentInSilo \
        computeSha1 \
        mkdirWithParentsPermissions \
        isSharedDir \
        cfg_silo_add \
        die
    genprgCallMain
}

genprgFilterSmudge() {
    genprgShbang
    genprgMainSmudge
    genprgFunctions \
        cmd_filter_smudge \
        cfg_contentSizeLimit \
        getCfgSizeVarWithDefault \
        validSha1 \
        getSiloObjectDir \
        getSiloDir \
        fileSize
    genprgCallMain
}

genprgShbang() {
    cat <<\EOF
#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail
set -o noglob

EOF
}

genprgMainClean() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    cmd_filter_clean
}

EOF
}

genprgMainSmudge() {
    cat <<\EOF
main() {
    (( $# == 1 )) || die "Require one argument with path to file."
    arg_file="${1}"
    cmd_filter_smudge
}

EOF
}

genprgCallMain() {
    cat <<\EOF
main "$@"
EOF
}

genprgFunctions() {
    for f in "$@"; do
        declare -f $f
        echo
    done
}

computeSha1AndStoreContentInSilo() {
    local silodir sha1 subdir objfile
    silodir=$(getSiloObjectDir)
    sha1=$(computeSha1) || die "Failed to compute sha1."
    subdir=$silodir/${sha1:0:2}
    objfile=$subdir/${sha1:2}
    if [ ! -e "$objfile" ]; then
        mkdirWithParentsPermissions "$subdir"
        case $(cfg_silo_add) in
        link)
            ln "$arg_file" "$objfile" >/dev/null 2>&1 ||
            cp "$arg_file" "$objfile"
            chmod a-w "$objfile"
            ;;
        copy)
            cp "$arg_file" "$objfile"
            chmod a-w "$objfile"
            ;;
        esac
    fi
    printf '%s\n' $sha1
}

cfg_silo_add() {
    local option
    option=$(git config silo.add) || option=link
    case $option in
    link|copy)
        ;;  # OK
    *)
        printf "Warning: invalid option silo.add = '%s'; using 'link'.\n" "$option" >&2
        option=link
        ;;
    esac
    echo $option
}

cfg_ismasterstore() {
    git config silo.ismasterstore || echo "true"
}

cmd_filter_smudge() {
    local silodir sha1
    IFS= read -r -n 41 sha1
    validSha1 "$sha1" || die "Invalid input; expected sha1: $arg_file"
    IFS= read -r -n 1 dummy && die "Input too large."
    silodir="$(getSiloObjectDir)"
    objfile="${silodir}/${sha1:0:2}/${sha1:2}"
    if [ -e "${objfile}" ]; then
        local contentSizeLimit=$(cfg_contentSizeLimit)
        if [ $contentSizeLimit -eq 0 ] ||
            [ $(fileSize "${objfile}") -lt $contentSizeLimit ]; then
            cat "${objfile}"
        else
            printf >&2 "using placeholder: %s\n" "${arg_file}"
            printf '%s\n' ${sha1}
        fi
    else
        printf >&2 "missing silo content: %s\n" "${arg_file}"
        printf '%s\n' "${sha1}"
    fi
}

cfg_contentSizeLimit() {
    getCfgSizeVarWithDefault "contentSizeLimit" "10M"
}

cfg_packSizeLimit() {
    getCfgSizeVarWithDefault "packSizeLimit" "50G"
}

getCfgSizeVarWithDefault() {
    local var="$1"
    local default="$2"
    local size
    size=$(git config silo.${var}) || size=${default}
    if ! egrep -q '^(0|[1-9][0-9]*)[kKmMgG]?$' <<<"${size}"; then
        printf >&2 \
            "Warning: invalid silo.%s=%s, using default.\n" "${var}" "${size}"
        size=${default}
    fi
    # Expand potential suffix and compute size.
    size=$(sed \
        -e 's/[kK]/*1024/' -e 's/[mM]/*1048576/' -e 's/[gG]/*1073741824/' \
        <<<"${size}")
    printf "%d" $(( ${size} ))
}

# Determine file size for large files on Mac, Linux and msysgit.
# Because the output format of BSD find and GNU find differ, sed is used
# to remove all leading characters before the permission field.
# Because msysgit's ls reports the wrong size for large files, find is used
# instead.
fileSize() {
    find "$1" -ls | sed -e 's/  */ /g' -e 's/^[^-]*-/-/' | cut -d ' ' -f 5
}

validateHaveSilo() {
    local silodir
    silodir=$(getSiloObjectDir)
    [ -d "$silodir" ] || die "Missing silo '$silodir'; run 'git-silo init'."
}

getSiloDir() {
    local silodir
    silodir="$(git rev-parse --git-dir)"
    silodir="$(cd "${silodir}" && pwd)"
    silodir="${silodir}/silo"
    printf '%s' "${silodir}"
}

getSiloBinDir() {
    printf '%s/%s' "$(getSiloDir)" "bin"
}

getSiloObjectDir() {
    printf '%s/%s' "$(getSiloDir)" "objects"
}

getSiloPackDir() {
    printf '%s/%s' "$(getSiloDir)" "packs"
}

mktempSiloDir() {
    local tmp
    tmp="$(getSiloDir)/tmp$$"
    mkdir "${tmp}" ||
        die "Failed to create tmpdir '${tmp}'."
    printf '%s' "${tmp}"
}

computeSha1() {
    openssl sha1 | cut -d ' ' -f 2 | egrep '^[0-9a-f]{40}$'
}

validSha1() {
    egrep -q '^[0-9a-f]{40}$' <<< "$1"
}

# Files should not end in CRLF, because .gitattributes sets -text on
# placeholders.  In case, however, the file get checked out with CRLF, it should
# be accepted as a placeholder.
isSha1PlaceholderFile() {
    local size=$(fileSize "$1")
    [ $size -eq 41 -o $size -eq 42 ] &&
    egrep -q $'^[0-9a-f]{40}\r?$' "$1"
}

cmd_add() {
    validateHaveSilo
    while read p; do
        [ "$p" = "" ] && continue
        updateGitattributes "$p"
        git add "$p"
    done <<< "$(lsUntrackedFiles)"
}

cmd_checkout() {
    validateHaveSilo
    local sha1 path silodir objfile
    silodir=$(getSiloObjectDir)
    local haveErr=
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if ! [ -e "$path" ] ||
            isSha1PlaceholderFile "$path" ||
            ( test $opt_copy && [ $(linkCount "$path") -gt 1 ] ) ||
            ( test $opt_link && [ $(linkCount "$path") -eq 1 ] )
        then
            objfile=$silodir/${sha1:0:2}/${sha1:2}
            if ! test -e "$objfile"; then
                printf >&2 "missing silo content: %s\n" "$path"
                haveErr=t
                continue
            fi
            mkdir -p "$(dirname "$path")"
            (
                ! test $opt_copy &&
                rm -f "$path" &&
                ln "$objfile" "$path" >/dev/null 2>&1 && (
                    ! test -w "$path" ||
                    chmod a-w "$path" >/dev/null 2>&1 || (
                        test $opt_link &&
                        echo "Warning: failed to set read-only permissions, falling back to copy '$path'." >&2 &&
                        false
                    )
                ) &&
                printf "Linking %s %s\n" "${sha1}" "${path}"
            ) || (
                rm -f "$path" &&
                cp "$objfile" "$path" &&
                chmod u+w "$path" &&
                printf "Copying %s %s\n" "${sha1}" "${path}"
            ) || {
                printf >&2 "Failed to copy '%s' to '%s'.\n" "$objfile" "$path"
                haveErr=t
                continue
            }
            git add -u -- "$path"  # Update index, so that 'git status' is clean.
        fi
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
    test $haveErr && die "There have been problems during silo checkout (see above)."
    true
}

linkCount() {
    ls -l "$1" | sed -e 's/  */ /' | cut -d ' ' -f 2
}

lsUntrackedFiles() {
    git ls-files --exclude-standard --exclude=.git* -o -- "${arg_pathspec[@]}"
}

updateGitattributes() {
    local p dir base gitignore
    p="$1"
    dir="$(dirname "$p")"
    base="$(basename "$p")"
    gitattributes="$dir/.gitattributes"
    tmpfile="$gitattributes-tmp$$"

    if hasGitSiloAttributes "${p}"; then
        return 0
    fi

    local endl=$(getWorkingCopyEndl)
    [ -e "$gitattributes" ] || touch "$gitattributes"
    ( printf '/%s filter=silo -text'$endl "$(escapeSpacesForGitattributes "$base")" && cat "$gitattributes") |
        sort -u >"$tmpfile"
    mv "$tmpfile" "$gitattributes"
    git add "$gitattributes"
}

hasGitSiloAttributes() {
    local p="${1}"
    [[ $(getAttrValue text "${p}") == "unset" ]] &&
        [[ $(getAttrValue filter "${p}") == "silo" ]]
}

getAttrValue() {
    local attr="${1}"
    local path="${2}"
    # check-attr's output is '<path> COLON SP <attribute> COLON SP <info> LF'.
    # Split on COLON and remove SP to handle <path> with spaces.
    git check-attr "${attr}" "${path}" | cut -d : -f 3 | cut -b 2-
}

getWorkingCopyEndl() {
    local cfg_autocrlf
    if cfg_autocrlf=$(git config core.autocrlf) &&
            [ $cfg_autocrlf = 'true' ]; then
        echo '\r\n'
    else
        echo '\n'
    fi
}

# .gitattributes doesn't support spaces, so replace them by ?.
escapeSpacesForGitattributes() {
    tr ' ' '?' <<< "$1"
}

cmd_status() {
    validateHaveSilo
    local sha1 path
    while read sha1 path; do
        [ "$path" = "" ] && continue
        if isSha1PlaceholderFile "$path"; then
            printf 'placeholder '
        else
            printf 'content     '
        fi
        printf '%s\n' "$path"
    done <<< "$(lsSiloTracked "${arg_pathspec[@]}")"
}

lsSiloTracked() {
    local perm ty gitsha1 size path sha1
    while read perm ty gitsha1 size path; do
        [ "$path" = "" ] && continue
        if [ "$path" != "" ] && [ "$size" = 41 ] && \
            sha1=$(getSha1ForGitObject $gitsha1); then
            printf '%s %s\n' "$sha1" "$path"
        fi
    done <<< "$(lsTree "$@")"
}

lsTree() {
    git ls-tree -rl HEAD -- "$@"
}

getSha1ForGitObject() {
    git show $1 | egrep '^[0-9a-f]{40}$'
}

cmd_push() {
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    else
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silopush) ) ||
            pathspec=()
        unset IFS
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "push"
    validateHaveSilo
    local url transport
    url=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Pushing silo to $url"
    lsSiloTracked "${pathspec[@]}" |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        sha1sAsObjectPaths |
        transport_${transport}_push "$url"
}

cmd_fetch() {
    local pathspec
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    if test "$arg_pathspec"; then
        pathspec=( "${arg_pathspec[@]}" )
    else
        IFS=$'\n'
        pathspec=( $(git config --get-all remote."${remote}".silofetch) ) ||
            pathspec=()
        unset IFS
    fi
    (( ${#pathspec[@]} )) || dieMissingPath "fetch"
    validateHaveSilo
    local url transport
    url=$(getRemoteSiloUrl)
    transport=$(getTransport "$url")
    echo "Fetching silo from $url"
    lsSiloTracked "${pathspec[@]}" |
        filterSiloAttr "${arg_filter[@]}" |
        uniqSha1s |
        sha1sAsObjectPaths |
        transport_${transport}_fetch "$url"
}

# transport_sshcat
transport_sshcat_fetch() {
    local silodir url dir objPathMap
    local url_host url_dir psha1 tmp
    url=$1
    read url_host url_dir <<< "$(parseUrl "$url")"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    remoteObjs=$(lsRemoteDir "$url_host" "$url_dir")
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$silodir/$p" ] && continue
        if ! findLineIn "$p" "$remoteObjs"; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"
        if test $opt_dry_run; then
            continue
        fi
        dir="$(dirname "$p")"
        mkdirWithParentsPermissions "$silodir/$dir"
        tmp="${silodir}/${p}-tmp"
        exec_ssh </dev/null "${url_host}" "cat '${url_dir}/${p}'" >"${tmp}" ||
            die "Failed to copy '$p'."
        chmod a-w "${tmp}"
        psha1=${p//\//}
        if [ $(computeSha1 <"${tmp}") != "${psha1}" ]; then
            rm -f "${tmp}"
            die "Checksum mismatch."
        fi
        mv "${tmp}" "$silodir/$p"
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

transport_sshcat_push() {
    local silodir url objPathMap url_host url_dir existing remotep
    url=$1
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    read url_host url_dir <<< "$(parseUrl "$url")"
    existing=$(lsRemoteDir "$url_host" "$url_dir")
    while read p; do
        [ "$p" = "" ] && continue
        findLineIn "$p" "$existing" && continue
        if ! [ -f "$silodir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            continue
        fi
        cat "${silodir}/${p}" | exec_ssh "${url_host}" \
            bash -c "$(genprgRemoteCatReceive | escapeSSHRemoteArg)" \
            git-silo-receive "'${url_dir}'" "'${p}'" ||
                die "Failed to copy '$p'."
    done
}

genprgRemoteCatReceive() {
    genprgShbang
    genprgFunctions \
        computeSha1 \
        die
    genprgRemoteCatReceiveImpl
}

genprgRemoteCatReceiveImpl() {
    cat <<\EOF
silodir="$1"
obj="$2"
objsha1="${obj//\//}"

if ! test -d "${silodir}"; then
    die "Missing silo dir '${silodir}' (run 'git-silo init' at remote to create it)."
fi
cd "${silodir}"
subdir="$(dirname "${obj}")"
if ! [ -e "${subdir}" ]; then
    mkdir "${subdir}"
    if test -g "."; then
        chmod g+ws "${subdir}"
    fi
fi

tmp="${obj}-tmp"
cat >"${tmp}"
chmod a-w "${tmp}"
if [ $(computeSha1 <"${tmp}") != "${objsha1}" ]; then
    rm -f "${tmp}"
    die "Checksum mismatch."
fi
chmod g+r "${tmp}"
mv "${tmp}" "${obj}"
EOF
}

lsRemoteDir() {
    exec_ssh "$1" bash -s <<EOFPRG |
set -o errexit
if test -e '$2'; then
    cd '$2'
    find . -type f
fi
EOFPRG
    sed -e 's@^\./@@' ||
        die "Failed to list silo objects at '$1' in '$2'."
}
# transport_sshcat

# transport_sshtar
transport_sshtar_fetch() {
    local url url_host url_dir objPathMap silodir
    url=$1
    read -r url_host url_dir <<< "$(parseUrl "$url")"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)

    tmpdir="$(mktempSiloDir)"
    # Clean up on exit.  Handlers for SIG* need to be set for Linux.  On Mac,
    # EXIT alone is sufficient.  Interestingly, setting 'true' as a handler for
    # SIG* also works.  The EXIT handler seems to be executed only if the
    # signal is handled somehow, how in detail does not matter.
    trap "rm -rf '${tmpdir}'" EXIT
    trap "rm -rf '${tmpdir}'; exit 1" SIGHUP SIGINT SIGTERM

    while read -r p; do
        [ "${p}" == "" ] && continue
        [ -f "${silodir}/${p}" ] && continue
        echo ${p}
    done | { {
            exec_ssh 2>&4 "${url_host}" \
                bash -c "$(genprgRemoteTarSend | escapeSSHRemoteArg)" git-silo-send "'${url_dir}'" |
            ( cd "${tmpdir}" && tar -xvf - 2>&1 ) |
            while read -r obj; do
                [ -z "${obj}" ] && continue
                egrep -q '^(x )?[0-9a-f]{2}/[0-9a-f]{38}$' <<<"${obj}" || {
                    # Forward unknown messages to stderr.
                    printf >&2 '%s\n' "${obj}"
                    continue
                }
                obj="${obj#x }"  # remove potential bsdtar 'x ' prefix.
                mkdirWithParentsPermissions "${silodir}/$(dirname $obj)"
                chmod a-wx "${tmpdir}/${obj}"
                # ln, don't mv, so that unpacking tar can still see the file.
                ln "${tmpdir}/${obj}" "${silodir}/${obj}"
                printSyncInfo "Received" "${obj}" "${objPathMap}"
            done
        } 4>&1 >&3 | {
            # Process stderr of remote ssh command.
            # See the following links for file descriptor dup:
            # http://wiki.bash-hackers.org/howto/redirection_tutorial
            # https://groups.google.com/d/msg/comp.unix.shell/ZCBtFUiUpO8/WXCUd84tIagJ
            areMissing=
            while read -r msg obj; do
                [ -z "${msg}" ] && continue
                [ "${msg}" == "missing" ] &&
                    egrep -q '^[0-9a-f]{2}/[0-9a-f]{38}$' <<<"${obj}" || {
                    # Forward unknown messages to stderr.
                    printf >&2 '%s %s\n' "${msg}" "${obj}"
                    continue
                }
                printSyncInfo >&2 "Warning: missing" "${obj}" "${objPathMap}"
                areMissing=t
            done
            test $areMissing &&
                die "Some files are missing at remote (see above)."
            true
        }
    } 3>&1 || exit $?

    rm -rf "${tmpdir}"
}

genprgRemoteTarSend() {
    genprgShbang
    genprgTarExistingFiles
}

genprgTarExistingFiles() {
    cat <<\EOF
[ -d "$1" ] || {
    printf >&2 "Warning: silo dir does not exist: %s\n" "$1"
    COPYFILE_DISABLE=1 tar -cf - -T /dev/null
    exit 0
}
cd "$1"
while read p; do
    [ "${p}" = "" ] && continue
    if ! [ -f "${p}" ]; then
        printf >&2 'missing %s\n' "${p}"
        continue
    fi
    echo ${p}
done |
COPYFILE_DISABLE=1 tar -cf - -T -
EOF
}

# COPYFILE_DISABLE avoids resource forks with Mac OS X tar.  See
# http://superuser.com/questions/259703/get-mac-tar-to-stop-putting-filenames-in-tar-archives
transport_sshtar_push() {
    local url_host url_dir silodir objPathMap
    read url_host url_dir <<< "$(parseUrl "$1")"
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    cat |
    exec_ssh "${url_host}" \
        bash -c "$(genprgRemoteEchoMissing | escapeSSHRemoteArg)" \
        git-silo-receive-prep "'${url_dir}'" |
    while read p; do
        [ -z "$p" ] && continue
        if ! [ -f "${silodir}/${p}" ]; then
            printSyncInfo "Warning: missing" "${p}" "${objPathMap}" >&2
            continue
        fi
        printf '%s\n' "${p}"
    done |
    ( cd "${silodir}" && COPYFILE_DISABLE=1 tar -cf - -T - ) |
    exec_ssh "${url_host}" \
        bash -c "$(genprgRemoteTarReceive | escapeSSHRemoteArg)" \
        git-silo-receive "'${url_dir}'" |
    while read -r obj; do
        [ -z "${obj}" ] && continue
        egrep -q '^(x )?[0-9a-f]{2}/[0-9a-f]{38}$' <<<"${obj}" ||
            die "Unexpected msg: ${obj}"
        obj="${obj#x }"  # remove potential bsdtar 'x ' prefix.
        printSyncInfo "Pushed" "${obj}" "${objPathMap}"
    done
}

genprgRemoteEchoMissing() {
    genprgShbang
    genprgFunctions \
        die
    genprgEchoObjsMissingInSilo
}

genprgEchoObjsMissingInSilo() {
    cat <<\EOF
[ -d "$1" ] || die "Missing silo dir '$1' (run 'git-silo init' at remote to create it)."
cd "$1"

while read -r p; do
    [ -z "${p}" ] && continue
    [ -f "${p}" ] && continue
    printf '%s\n' "${p}"
done
EOF
}

genprgRemoteTarReceive() {
    genprgShbang
    genprgFunctions \
        die \
        mkdirWithParentsPermissions \
        isSharedDir
    genprgRemoteUntar
}

genprgRemoteUntar() {
    cat <<\EOF
[ -d "$1" ] || die "Missing silo dir '$1' (run 'git-silo init' at remote to create it)."
cd "$1"

tmpdir="tmp$$"
trap "rm -rf '${tmpdir}'" EXIT
trap "rm -rf '${tmpdir}'; exit 1" SIGHUP SIGINT SIGTERM
mkdir "$tmpdir"

( cd "${tmpdir}" && tar -xvf - 2>&1 ) |
while read -r obj; do
    [ -z "${obj}" ] && continue
    egrep -q '^(x )?[0-9a-f]{2}/[0-9a-f]{38}$' <<<"${obj}" || {
        printf >&2 '%s\n' "${obj}"
        continue
    }
    obj="${obj#x }"  # remove potential bsdtar 'x ' prefix.
    mkdirWithParentsPermissions "$(dirname ${obj})"
    chmod a-wx "${tmpdir}/${obj}"
    chmod g+r "${tmpdir}/${obj}"
    # ln, don't mv, so that unpacking tar can still see the file.
    ln "${tmpdir}/${obj}" "${obj}"
    echo x ${obj}
done

rm -rf "${tmpdir}"
EOF
}
# transport_sshtar

exec_ssh() {
    local defaultargs=
    local ssh=${GIT_SSH:-ssh}
    case "$ssh" in
    *plink*)
        defaultargs=-batch
        ;;
    esac
    "$ssh" $defaultargs "$@"
}

# Escape arg so that it can be passed to ssh as a remote arg:
#
#   ssh bash -c "$(genprg | escapeSSHRemoteArg)"
#
# The entire arg is wrapped in single quotes.  Internal single quotes are
# escaped as '"'"'.
escapeSSHRemoteArg() {
    echo "'"
    sed -e "s/'/'\"'\"'/g"
    echo "'"
}

transport_localcp_fetch() {
    local silodir url dir objPathMap src dest tmp
    url=$1
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    local areMissing=
    while read p; do
        [ "$p" = "" ] && continue
        src="${url}/${p}"
        dest="${silodir}/${p}"
        [ -f "${dest}" ] && continue
        if ! [ -e "${src}" ]; then
            areMissing=t
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Fetching" "$p" "$objPathMap"

        if test $opt_dry_run; then
           continue
        fi

        dir="$(dirname "$p")"
        mkdirWithParentsPermissions "$silodir/$dir"

        # Try to link, but only if source has correct permissions.
        if ! test -w "${src}"; then
            echo_debug "ln $src ..."
            if ln "${src}" "${dest}" >/dev/null 2>&1; then
                continue
            fi
        fi

        echo_debug "cp ${src} ..."
        tmp="${dest}-tmp"
        rm -f "${tmp}"
        cp "${src}" "${tmp}" ||
            die "Failed to copy '$p'."
        chmod a-w "${tmp}"
        mv "${tmp}" "${dest}"
    done
    test $areMissing && die "Some files are missing at remote (see above)."
    true
}

transport_localcp_push() {
    local silodir url objPathMap url_host url_dir existing
    url=$1
    if ! [ -d "$url" ]; then
        die "Missing silo dir '$url' (run 'git-silo init' at remote to create it)."
    fi
    objPathMap=$(lsSiloTracked "${pathspec[@]}")
    silodir=$(getSiloObjectDir)
    while read p; do
        [ "$p" = "" ] && continue
        [ -f "$url/$p" ] && continue
        if ! [ -f "$silodir/$p" ]; then
            printSyncInfo "Warning: missing" "$p" "$objPathMap" >&2
            continue
        fi
        printSyncInfo "Pushing" "$p" "$objPathMap"
        if test $opt_dry_run; then
            echo_debug "Would have run: cp" "$silodir/$p" "$url/$p"
        else
            dir=$(dirname $p)
            mkdirWithParentsPermissions "$url/$dir"
            echo_debug "cp ..."
            rm -f "$url/$p-tmp"
            cp "$silodir/$p" "$url/$p-tmp"
            chmod a-w "$url/$p-tmp"
            chmod g+r "$url/$p-tmp"
            mv "$url/$p-tmp" "$url/$p"
        fi
    done
}

printSyncInfo() {
    local msg=$1
    local p=$2
    local objPathMap=$3
    local sha1=$(cut -b 1-2,4-41 <<<"$p")
    grep $sha1 <<<"$objPathMap" |
        sed -e "s/^/$msg /"
}

mkdirWithParentsPermissions() {
    local d=$1
    local parentd=$(dirname "$d")
    if [ -d "$d" ]; then
        return 0
    fi
    mkdir -p "$d"
    if isSharedDir "$parentd"; then
        chmod g+ws "$d"
    fi
}

isSharedDir() {
    test -g "$1"
}

# Lines must not contain special basic regex characters.
# SHA1s are ok.  Relative silo object paths 'xx/xxx...' are also ok.
findLineIn() {
    grep -q "^$1\$" <<< "$2"
}

getTransport() {
    if [ "${1/://}" = "$1" ] || isWindowsAbsPath "$1"; then
        echo localcp
    else
        cfg_sshtransport
    fi
}

cfg_sshtransport() {
    local o
    o=$(git config silo.sshtransport) || o=sshcat
    case ${o} in
    sshtar|sshcat)
        echo ${o}
        ;;
    *)
        printf "Warning: invalid option silo.sshtransport = '%s'; using 'sshcat'.\n" "${o}" >&2
        echo sshcat
    esac
}

isWindowsAbsPath() {
    grep -q '^[a-zA-Z]:/' <<< "$1"
}

parseUrl() {
    sed -e 's/:/ /' <<< "$1"
}

uniqSha1s() {
    cut -b 1-40 |
    sort -u
}

# Add slashes every second prefix hexdigit if followed by more hexdigits.
slashedPrefix() {
    local prev=
    local cur="$1"
    while [ "${prev}" != "${cur}" ]; do
        prev="${cur}"
        # Transform '^aaa -> ^aa/a' and '.../aaa' -> '.../aa/a'.
        cur=$(sed -E -e 's@(^|/)([0-9a-f]{2})([0-9a-f])@\1\2/\3@g' <<<"${cur}")
    done
    printf '%s' "${cur}"
}

# Add slash after starting two hexdigits if followed by another hexdigit.
slashedOnce() {
    sed -E -e 's@^([0-9a-f]{2})([0-9a-f])@\1/\2@'
}

sha1sAsObjectPaths() {
    slashedOnce
}

sha1AsObjectPath() {
    local sha1="$1"
    echo ${sha1:0:2}/${sha1:2}
}

filterSiloAttr() {
    local attr
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue
        attr=$(getAttrValue "silo" "${path}")
        if ! passFilter "$attr" "$@"; then
            test $opt_verbose && printf "    skipping %s\n" "${path}" >&2
            continue
        fi
        printf '%s %s\n' "${sha1}" "${path}"
    done
}

passFilter() {
    local attr=$1
    shift
    for f in "$@"; do
        read -r cmd label <<<"${f}"
        case ",${attr}," in
        *,${label},*)
            case "${cmd}" in
            +)
                return 0
                ;;
            -)
                return 1
                ;;
            *)
                die "Invalid filter command in filter rule '${cmd} ${label}'."
            esac
            ;;
        esac
    done
    return 0
}

getRemoteSiloUrl() {
    local url reurl
    local remote=origin
    test "$arg_remote" && remote="$arg_remote"
    url=$(git config remote."${remote}".url) ||
        die "Failed to get URL of remote '${remote}'.  If you meant '${remote}' to be a path, separate it by a double dash: '-- ${remote} ...'."
    if grep -q '^ssh://' <<< "$url"; then
        url=$(sed -e 's@ssh://@@' -e 's@/@:/@' -e 's@//@/@' \
            -e 's@:/~@:~@' <<< "$url")
    elif grep -q '^[^:]*://' <<< "$url"; then
        die "Don't know how to use $url."
    fi
    reurl=$(resolveGitDir "$url") ||
        die "Failed to resolve git-dir for '$url'."
    printf '%s/silo/objects\n' "$reurl"
}

resolveGitDir() {
    local url=$1
    local url_host url_dir
    case $(getTransport "$url") in
    localcp)
        url=$(cd "$url" && cd "$(git rev-parse --git-dir)" && pwd)
        ;;
    sshtar|sshcat)
        read url_host url_dir <<< "$(parseUrl "$url")"
        url_dir=$(
            exec_ssh "$url_host" bash -s <<EOFPRG
set -o errexit
test -e '$url_dir'
cd '$url_dir'
cd "\$(git rev-parse --git-dir)"
pwd
EOFPRG
        ) || die "Failed 'ssh $url_host bash ...' to determine git-dir."
        url=$url_host:$url_dir
        ;;
    esac
    printf '%s' "$url"
}

cmd_gc() {
    validateNoStagedChanges
    test $opt_force || validateNoUnstagedChanges
    validateHaveSilo
    gcSiloObjects
    if test $opt_gitattributes; then
        gcAllGitattributes
    fi
}

gcSiloObjects() {
    local silodir current stored remove
    current=$(allCurrentSiloObjects)
    current=$(convertToObjectSubdirPaths <<< "$current")

    silodir=$(getSiloObjectDir)
    stored=$(lsDir "$silodir")

    remove=$(setminus "$stored" "$current")
    if test $opt_dry_run; then
        sed -e 's/^/Would remove /' <<<"${remove}"
        return 0
    fi
    ( cd "$silodir" && xargs rm -vf ) <<<"${remove}" |
        sed -e 's/^/Removing /'
    removeEmptyObjectDirs
}

removeEmptyObjectDirs() {
    find "$(getSiloObjectDir)" \
        -mindepth 1 -maxdepth 1 -type d -empty -exec rmdir '{}' ';' || true
}

cmd_purge() {
    validateHaveSilo

    local orphanSha1s silodir shouldRemoveObject sha1 path objpath
    local msg_remove msg_placeholder

    [[ $(cfg_ismasterstore) == "false" ]] ||
        die "purge requires silo.ismasterstore=false."

    test $opt_force || test $opt_dry_run ||
        die "purge requires either -f or --dry-run."

    (( ${#arg_pathspec[@]} )) ||
        die "purge requires a path."

    validateNoStagedChanges
    validateNoUnstagedChanges

    if test $opt_force; then
        msg_remove="Removing"
        msg_placeholder="Using placeholder"
    else
        msg_remove="Would remove"
        msg_placeholder="Would use placeholder"
    fi

    orphanSha1s="$(orphanSha1sWithoutPaths "${arg_pathspec[@]}")"
    silodir=$(getSiloObjectDir)

    lsSiloTracked "${arg_pathspec[@]}" |
    while read -r sha1 path; do
        [ "${sha1}" = "" ] && continue

        objpath="${silodir}/$(sha1AsObjectPath "${sha1}")"
        if [ -f "${objpath}" ] && grep -q -F "${sha1}" <<<"${orphanSha1s}"; then
            shouldRemoveObject=t
            printf "%s %s %s\n" "${msg_remove}" "${sha1}" "${path}"
        elif ! isSha1PlaceholderFile "${path}"; then
            shouldRemoveObject=
            printf "%s %s %s\n" "${msg_placeholder}" "${sha1}" "${path}"
        else
            continue
        fi

        if ! test $opt_force; then
            continue
        fi

        rm -f "${path}"
        printf '%s\n' "${sha1}" >"${path}"
        git add -u "${path}"

        if ! test $shouldRemoveObject; then
            continue;
        fi

        rm -f "${objpath}"
    done

    removeEmptyObjectDirs
}

# Count how often a sha1 is used (1) by all files of HEAD and (2) when files
# are restricted to paths.  Join counts on sha1 and keep only sha1s that are
# present in both sets with same count.  These sha1s become orphans when the
# paths are removed.
orphanSha1sWithoutPaths() {
    (
        lsSiloTracked | sha1Counts &&
        lsSiloTracked "$@" | sha1Counts
    ) |
    joinCounts |
    sha1sWithEqualCounts
}

# Join counts from consecutive lines with equal sha1.
joinCounts() {
    local sha1 c prevc
    local prevsha1=

    sed -e 's/^ *//' |
    sort -s -k 2 |
    while read -r c sha1; do
        [ "${sha1}" = "" ] && continue
        if [ "${sha1}" = "${prevsha1}" ]; then
            printf "%s %s %s\n" "${sha1}" "${prevc}" "${c}"
        fi
        prevsha1="${sha1}"
        prevc="${c}"
    done
}

sha1sWithEqualCounts() {
    local sha1 c1 c2
    while read -r sha1 c1 c2; do
        [ "${sha1}" = "" ] && continue
        (( $c1 != $c2 )) && continue
        printf '%s\n' "${sha1}"
    done
}

sha1Counts() {
    cut -b 1-40 |
    sort |
    uniq -c
}

lsDir() {
    cd "$1" && find . -type f | sed -e 's@^\./@@'
}

lsSiloObjectsInDirWithSize() {
    lsDirWithSize "$1" |
    egrep ' [0-9a-f]{2}/[0-9a-f]{38}$' || true
}

# Use find to determine correct file size on msysgit.  Use sed to normalize
# output of 'find -ls' (compress whitespace, remove everything before
# permission field).  Use sed to remove leading './' See also note at
# fileSize().
lsDirWithSize() {
    (
        cd "$1" &&
        find . -type f -ls |
        sed -e 's/  */ /g' -e 's/^[^-]*-/-/' |
        cut -d ' ' -f 5,9 |
        sed -e 's@\./@@'
    )
}

allCurrentSiloObjects() {
    if test $opt_n; then
        while read ref; do
            [ "$ref" = "" ] && continue
            siloObjectsWithRevListArgs -n $opt_n $ref
        done <<< "$(allLocalRefs)" |
        sort -u
    else
        siloObjectsWithRevListArgs --all
    fi
}

siloObjectsWithRevListArgs() {
    git rev-list --objects "$@" |
    cut -d ' ' -f 1 |
    git cat-file --batch-check |
    ( grep 'blob 41$' || true ) |  # Avoid pipefail without match.
    cut -d ' ' -f 1 |
    sort -u |
    while read blob; do
        [ -z "$blob" ] && continue
        if sha1=$(getSha1ForGitObject $blob); then
            printf '%s\n' "$sha1"
        fi
    done
}

allLocalRefs() {
    git rev-parse HEAD
    git show-ref --heads $(test $opt_tags && echo --tags) -s
}

convertToObjectSubdirPaths() {
    sed -e 's@^\(.\{2\}\)@\1/@'
}

# Lines must not contain special basic regex characters.
# SHA1s are ok.  Relative silo object paths 'xx/xxx...' are also ok.
setminus() {
    while read l; do
        findLineIn "$l" "$2" && continue
        printf '%s\n' "$l"
    done <<< "$1"
}

gcAllGitattributes() {
    while IFS= read -r p; do
        [ "$p" = "" ] && continue
        gcGitattributes "${p}"
    done <<< "$(lsGitattributes)"
    test $opt_dry_run && return 0
    git commit -m "git-silo gc gitattributes" &&
        echo "Consider amending the commit to explain the reason."
    true
}

gcGitattributes() {
    local attr tmpfile dir reEntry
    attr="$1"
    dir="$(dirname "${attr}")"
    tmpfile="${attr}-tmp$$"
    reEntry='^/.*filter=silo -text$'
    grep -v "${reEntry}" "${attr}" >"${tmpfile}" || true
    while read path rest; do
        if [ -f "$dir/$path" ]; then
            printf '%s filter=silo -text\n' "$path" >>"${tmpfile}"
        fi
    done <<< "$(grep "$reEntry" "${attr}")"
    if test $opt_dry_run; then
        diff "${attr}" "${tmpfile}" >/dev/null || echo "Would clean up '$attr'."
        rm "${tmpfile}"
        return 0
    fi
    mv "${tmpfile}" "${attr}"
    git add "${attr}"
}

lsGitattributes() {
    git ls-files | egrep '^.gitattributes|/.gitattributes'
    true
}

cmd_fsck() {
    local silodir expected_sha1 actual_sha1
    validateHaveSilo
    silodir="$(getSiloObjectDir)"
    local haveErr=
    while read -r p; do
        [ "$p" = "" ] && continue
        expected_sha1=${p/\//}
        actual_sha1=$(computeSha1 <"$silodir/$p") ||
            die "Failed to compute sha1 for '$p'."
        if [ $expected_sha1 != $actual_sha1 ]; then
            printf 'Error: %s corrupted, has wrong sha1 %s\n' \
                "$p" "$actual_sha1"
            haveErr=t
        fi
    done <<<"$(lsSiloObjectsInDir "$silodir")"
    test $haveErr && die "There have been errors (see above)."
    echo ok
}

cmd_pack() {
    packtool=7z
    packext=7z
    requireBin7z

    validateHaveSilo
    mkSiloPackDir

    lsObjectsWithPackPrefix |
    sort -k 1 |
    forEachGroup updatePack

    prunePackedObjects
}

cmd_unpack() {
    packtool=7z
    packext=7z
    requireBin7z

    validateHaveSilo

    [ -d "$(getSiloPackDir)" ] || return 0

    lsObjectsSelectedForUnpack |
    dropSha1sOfLooseObjects |
    lookupPacksForObjects |
    sort -k 1 |
    forEachGroup unpackObjects

    test $opt_keep_packs || prunePacks
}

mkSiloPackDir() {
    local packdir="$(getSiloPackDir)"
    mkdirWithParentsPermissions "${packdir}"
}

lsObjectsSelectedForUnpack() {
    if test $opt_all; then
        lsPackedObjects
    else
        lsSiloTracked "${arg_pathspec[@]}" |
        cut -d ' ' -f 1
    fi
}

dropSha1sOfLooseObjects() {
    local objectdir="$(getSiloObjectDir)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        [ -e "${objectdir}/$(sha1AsObjectPath ${sha1})" ] && continue
        printf '%s\n' "${sha1}"
    done
}

lookupPacksForObjects() {
    local sha1
    local packidx="$(lsPacksWithObjects)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        grep "${sha1}\$" <<<"${packidx}" ||
            printf 'nopack %s\n' "${sha1}"
    done
}

unpackObjects() {
    local pack="$1"
    local sha1s="$2"
    local objectdir="$(getSiloObjectDir)"
    local packdir="$(getSiloPackDir)"
    local tmpdir

    [ "$pack" == "nopack" ] && return 0

    tmpdir="$(mktempSiloDir)"
    # Clean up on exit.  Handlers for SIG* need to be set for Linux.  On Mac,
    # EXIT alone is sufficient.  Interestingly, setting 'true' as a handler for
    # SIG* also works.  The EXIT handler seems to be executed only if the
    # signal is handled somehow, how in detail does not matter.
    trap "rm -rf '${tmpdir}'" EXIT
    trap "rm -rf '${tmpdir}'; exit 1" SIGHUP SIGINT SIGTERM

    printf '%s' "${sha1s}" | slashedOnce | (
        cd "${tmpdir}" &&
        packtool_${packtool}_extract "${packdir}/${pack}"
    ) || die "Failed to extract object files from archive."

    for sha1 in ${sha1s}; do
        subdir="${sha1:0:2}"
        objfile="${sha1:2}"
        mkdirWithParentsPermissions "${objectdir}/${subdir}"
        chmod a-w "${tmpdir}/${subdir}/${objfile}"
        mv "${tmpdir}/${subdir}/${objfile}" "${objectdir}/${subdir}/${objfile}"
    done

    rm -rf "${tmpdir}"
}

prunePackedObjects() {
    [ "${opt_keep}" == "all" ] && return 0

    local objectdir="$(getSiloObjectDir)"
    local tipobjs packedobjs sha1
    tipobjs=$(lsSiloTracked | cut -d ' ' -f 1)
    packedobjs=$(lsPackedObjects)
    lsSiloObjectsInDir "${objectdir}" |
    while IFS= read -r path; do
        [ -z "${path}" ] && continue
        sha1="${path/\//}"

        # Always skip unpacked.
        grep -q -F "${sha1}" <<<"${packedobjs}" || continue

        # Skip tip objects if requested.
        if [ "${opt_keep}" == "tip" ]; then
            grep -q -F "${sha1}" <<<"${tipobjs}" && continue
        fi

        echo "Removing ${path}"
        rm -f "${objectdir}/${path}"
    done
    removeEmptyObjectDirs
}

prunePacks() {
    lsPacksWithObjects |
    sort -k 1 |
    forEachGroup prunePack
}

prunePack() {
    local pack="$1"
    local objs="$2"

    haveAllLooseObjects "${objs}" || return 0

    local packdir="$(getSiloPackDir)"
    rm -f "${packdir}/${pack}"
}

haveAllLooseObjects() {
    local objectdir="$(getSiloObjectDir)"
    while IFS= read -r sha1; do
        [ -z "${sha1}" ] && continue
        [ -e "${objectdir}/$(sha1AsObjectPath ${sha1})" ] || return 1
    done <<<"${objs}"
}

# Determine pack prefix for loose objects.  Output: <prefix><SPACE><object>.
# Example:
#
#    _ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#    b_ bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
#    nopack cccccccccccccccccccccccccccccccccccccccc
#
# 'nopack' indicates that object is too large to pack.
# 'packed' indicates that object is contained in existing pack.
# 'tip' indicates that object is used by HEAD.
lsObjectsWithPackPrefix() {
    local packedobjs tipobjs prefixes
    local threshold=$(cfg_packSizeLimit)
    packedobjs=$(lsPackedObjects)
    tipobjs=$(lsSiloTracked | cut -d ' ' -f 1)
    for i in {0..39}; do
        prefixes[${i}]=''
    done
    local cumsums
    lsSiloObjectsInDirWithSize "$(getSiloObjectDir)" |
    sed -e 's@/@@' |
    sort -k 2 |
    while read -r size name; do
        [ -z "${name}" ] && continue
        # Debugging code:
        # printf >&2 "%s " "${prefixes[@]}"
        # echo >&2
        # printf >&2 "%d " "${cumsums[@]}"
        # echo >&2

        if grep -q -F "${name}" <<<"${packedobjs}"; then
            echo packed ${name}
            continue
        fi

        if ! test $opt_all &&
            grep -q -F "${name}" <<<"${tipobjs}"; then
            echo tip ${name}
            continue
        fi

        if (( ${threshold} > 0 )) && (( ${size} > ${threshold} )); then
            echo nopack ${name}
            continue
        fi

        for level in {0..39}; do
            curprefix="${name:0:${level}}_"
            if [ "${prefixes[${level}]}" != "${curprefix}" ]; then
                prefixes[${level}]=${curprefix}
                cumsums[${level}]=0
                oldpack=$(findPackWithPrefix "${curprefix}")
                if [ -n "${oldpack}" ]; then
                    cumsums[${level}]=$(fileSize "${oldpack}")
                fi
            fi
            newsize=$(( ${cumsums[${level}]} + ${size} ))
            if (( ${threshold} == 0)) || (( ${newsize} < ${threshold} )); then
                echo ${curprefix} ${name}
                cumsums[${level}]=${newsize}
                continue 2
            fi
        done
        echo nopack ${name}
    done
}

forEachGroup() {
    local prefix=
    local group
    while read -r p o; do
        [ -z "${p}" ] && continue
        if [ "${p}" != "${prefix}" ]; then
            if [ -n "${prefix}" ]; then
                "$@" "${prefix}" "${group}"
            fi
            prefix="${p}"
            group=
        fi
        group="${group}${o}
"
    done
    if [ -n "${prefix}" ]; then
        "$@" "${prefix}" "${group}"
    fi
}

updatePack() {
    local objectdir="$(getSiloObjectDir)"
    local packdir="$(getSiloPackDir)"
    local prefix="$1"
    local objs="$2"

    # Skip objects that are too large to be packed.
    [ "${prefix}" == "nopack" ] && return 0

    # Skip objects that are already packed.
    [ "${prefix}" == "packed" ] && return 0

    # Skip objects that are used by tip.
    [ "${prefix}" == "tip" ] && return 0

    # Compute preliminary id based on objects in pack.
    oldpack=$(findPackWithPrefix "${prefix}")
    packobjsid="$(
        (
            if [ -n "${oldpack}" ]; then
                packtool_${packtool}_ls "${oldpack}"
            fi &&
            printf '%s' "${objs}"
        ) |
        sed -e 's@/@@' |
        sort -u |
        computeSha1
        )"

    # Prepare tmp pack.
    pathprefix="${packdir}/$(slashedPrefix "${prefix}")"
    tmppackfile="${pathprefix}${packobjsid}.${packext}-tmp"
    mkdirWithParentsPermissions "$(dirname "${tmppackfile}")"
    rm -f "${tmppackfile}"

    # Add objects
    printf '%s' "${objs}" | slashedOnce | (
        cd "${objectdir}" &&
        packtool_${packtool}_add "${oldpack}" "${tmppackfile}"
    ) || die "Failed to add object files to archive."
    chmod a-w "${tmppackfile}"

    # Double check that pack contains the expected objects.
    verifyPackfileObjsId "${tmppackfile}"

    # Compute final pack id based on its sha1, move in place, and clean up.
    packcontentid=$(computeSha1 <"${tmppackfile}")
    packfile="${pathprefix}${packcontentid}.${packext}"
    mv "${tmppackfile}" "${packfile}"
    if [ -n "${oldpack}" ]; then
        rm -f "${oldpack}"
    fi
}

requireBin7z() {
    local try="7zr 7z"
    for b in $try; do
        if $b 2>&1 | grep -q "7-Zip"; then
            bin_7z=$b
            return
        fi
    done
    die "Missing 7z binary (tried $try).  If using a package manager (Linux or Mac), install the package 'p7zip'; or install 7-Zip from http://www.7-zip.org and add it to PATH."
}

packtool_7z_add() {
    local src="$1"
    local dest="$2"

    # Clean up if interrupted.
    trap "rm -f '${dest}'; exit 1" SIGHUP SIGINT SIGTERM

    if [ -n "${src}" ]; then
        cp "${src}" "${dest}"
        chmod u+w "${dest}"
    fi
    # Use LZMA2 to support multi-threaded compression.
    # Disable solid mode (-ms=off) to allow quickly accessing individual files.
    xargs ${bin_7z} a -t7z -m0=LZMA2 -ms=off "${dest}"

    trap - SIGHUP SIGINT SIGTERM
}

packtool_7z_extract() {
    local pack="$1"
    local parallel ncpu
    ncpu="$(nCPU)"
    if (( ${ncpu} > 1 )); then
        echo "Using up to ${ncpu} processes for unpacking."
        # Use separate process for each object (-n 1) for parallel execution.
        parallel="-P ${ncpu} -n 1"
    fi
    xargs ${parallel} ${bin_7z} x "${pack}"
}

packtool_7z_ls() {
    # Select rows that contain file listing (separated by lines that contain
    # '---').  Drop listing separators.  isolate file names by removing start
    # of line up to space (assuming file names w/o spaces).
    ${bin_7z} l "$1" |
    sed -n -e '/---/,/---/p' |
    sed -e '1d' -e '$d' |
    sed -e 's/^.* //'
}

# Determine number of CPUs.
nCPU() {
    local n=
    case $(uname) in
    Linux*)
        n="$(grep -c ^processor /proc/cpuinfo || true)"
        ;;
    Darwin*)
        n="$(sysctl hw.ncpu | cut -d ' ' -f 2 || true)"
        ;;
    esac
    if ! grep -q "^[1-9][0-9]*\$" <<<"${n}"; then
        n=1
    fi
    printf '%d' "${n}"
}

lsPackedObjects() {
    lsPacksWithObjects |
    cut -d ' ' -f 2
}

lsPacksWithObjects() {
    packdir="$(getSiloPackDir)"
    lsSlashedPacks |
    while IFS= read -r pack; do
        [ -z "${pack}" ] && continue
        packtool_${packtool}_ls "${packdir}/${pack}" |
        sed -e 's@/@@' -e "s@^@${pack} @"
    done
}

lsSlashedPacks() {
    (
        cd "$(getSiloPackDir)" &&
        find . -type f -name "*_*.${packext}" |
        cut -b 3-
    )
}

findPackWithPrefix() {
    local prefix="$(slashedPrefix "$1")"
    (
        set +o noglob &&
        shopt -s nullglob &&
        printf '%s' "$(getSiloPackDir)"/${prefix}*.${packext}
    )
}

verifyPackfileObjsId() {
    local packfile="$1"
    local packobjsid
    packobjsid="$(
        packtool_${packtool}_ls "$packfile" |
        sed -e 's@/@@' |
        sort |
        computeSha1
        )"
    packid="$(packIdOfFile "${packfile}")"
    if [ "${packid}" != "${packobjsid}" ]; then
        die "Id from object list ('${packobjsid}') does not match packfile name '$(basename "${packfile}")'."
    fi
}

packIdOfFile() {
    local packfile="$1"
    local packid="${packfile##*_}"
    packid="${packid%%.*}"
    printf '%s' "${packid}"
}

lsSiloObjectsInDir() {
    lsDir "$1" |
    egrep '^[0-9a-f]{2}/[0-9a-f]{38}$' || true
}

cmd_dedup() {
    for r in "${arg_repos[@]}"; do
        validateHaveSiloAt "$r"
    done

    local prev_key=invalid
    local prev_dir
    local src dest tmp
    lsAllDedupCandidates |
    while read -r key dir; do
        if [ $key != $prev_key ]; then
            prev_key=$key
            prev_dir=$dir
            continue
        fi
        src=$prev_dir/$key
        dest=$dir/$key
        # Skip if files already use same inode.
        if [ "$(inodeNumber "${src}")" = "$(inodeNumber "${dest}")" ]; then
            continue
        fi
        tmp=$dest-$$
        ln "$src" "$tmp" &&
        mv -f "$tmp" "$dest" || {
            printf "Warning: Failed to link '%s' from '%s' to '%s'.\n" \
                "$key" "$prev_dir" "$dir" >&2
        }
    done
}

inodeNumber() {
    ls -i "$1" | cut -d ' ' -f 1
}

validateHaveSiloAt() {
    ( cd "$r" && validateHaveSilo ) ||
        die "Invalid silo '$r'."
}

lsAllDedupCandidates() {
    for r in "${arg_repos[@]}"; do
        lsDedupCandidates "$r"
    done |
    sort -k 1.1,1.41 -s
}

lsDedupCandidates() {
    local abspath
    abspath=$( cd "$1" && cd "$(getSiloObjectDir)" && pwd )
    # '|| true' avoids pipefail without match.
    (
    lsDir "$abspath" |
    ( egrep '^[0-9a-f]{2}/[0-9a-f]{38}$' || true )
    ) |
    while read -r line; do
        printf '%s %s\n' "$line" "$abspath"
    done
}

validateNoStagedChanges() {
    no_staged_changes || die "You have staged changes."
}

validateNoUnstagedChanges() {
    no_unstaged_changes || die "You have unstaged changes."
}

no_staged_changes() {
    git diff-index --quiet --cached HEAD
}

no_unstaged_changes() {
    git diff-files --quiet
}

dieMissingPath() {
    local what="$1"
    msg="Missing path.  '${what}' requires a path, either on the command line or in 'remote.<remote>.silo${what}'."
    if test "${arg_remote}"; then
        msg="$msg  The first argument '${arg_remote}' was interpreted as a remote.  If you meant to use remote 'origin' and ${what} a path, separate the argument by a double dash: '-- ${arg_remote}'."
    fi
    die "${msg}"
}

die() {
    echo >&2 "Error (silo): $1"
    exit 1
}

echo_debug() {
    if test $opt_debug; then
        echo >&2 "$@"
    fi
}

main "$@"
